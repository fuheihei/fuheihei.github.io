<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/redis/data-type/"/>
    <url>/redis/data-type/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h1><p>根据官方文档内容介绍</p><p>五种基本数据结构 String, List, Hash, Set, Set</p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>key和value最大都是512MB，推荐设置成“user:1000”这样有意义的key。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> &lt;key&gt; &lt;value&gt;<br><span class="hljs-built_in">set</span> key value nx 如果已经存在，则设置失败，返回nil<br><span class="hljs-built_in">set</span> key value xx 如果存在，才能设置成功，返回OK<br><span class="hljs-built_in">set</span> key value ex 10 过期时间<br><br>get key<br><br>expire key 5 设置key的过期时间<br><br>ttl key 查看key的time to live（默认单位：秒）<br><br>del key 删除键<br><br>pexpire<br><br>pttl<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">计数器<br>&gt; <span class="hljs-built_in">set</span> counter 100<br>OK<br>&gt; incr counter<br>(<span class="hljs-built_in">integer</span>) 101<br>&gt; incr counter<br>(<span class="hljs-built_in">integer</span>) 102<br>&gt; incrby counter 50<br>(<span class="hljs-built_in">integer</span>) 152<br><br></code></pre></td></tr></table></figure><p><code>type key</code><br>查看key的value是什么类型，如果key不存在返回none</p><p>多设置，多获取（避免多次单次设置的网络延迟）</p><p>可以一次性获取多个值，一次性设置多个值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mset<br>mget<br></code></pre></td></tr></table></figure><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="创建List，左右添加元素"><a href="#创建List，左右添加元素" class="headerlink" title="创建List，左右添加元素"></a>创建List，左右添加元素</h3><p>lpush key &lt;元素列表&gt;<br>rpush</p><h3 id="阻塞获取元素"><a href="#阻塞获取元素" class="headerlink" title="阻塞获取元素"></a>阻塞获取元素</h3><p>lpop，rpop，blpop，brpop</p><p>blpop key 5<br>默认时间是秒<br>也可以阻塞获取多个key列表的元素<br>返回的是一个二元组，存在元素的key和key中的value，如果时间到了尚未获取到元素，则返回nil</p><p>将source列表中的最左侧或者最右侧移动到dest的末尾，过去是lpoprpush指令<br>lmove source dest &lt;right|left&gt; &lt;right|left&gt;</p><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p>hash的结构 key, pair&lt;field,value&gt;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql">hset <span class="hljs-keyword">user</span>:<span class="hljs-number">1000</span> username antirez birthyear <span class="hljs-number">1977</span> verified <span class="hljs-number">1</span><br>(<span class="hljs-type">integer</span>) <span class="hljs-number">3</span><br><br>hget <span class="hljs-keyword">user</span>:<span class="hljs-number">1000</span> username<br>&quot;antirez&quot;<br><br>hget <span class="hljs-keyword">user</span>:<span class="hljs-number">1000</span> birthyear<br>&quot;1977&quot;<br><br>hgetall <span class="hljs-keyword">user</span>:<span class="hljs-number">1000</span><br><span class="hljs-number">1</span>) &quot;username&quot;<br><span class="hljs-number">2</span>) &quot;antirez&quot;<br><span class="hljs-number">3</span>) &quot;birthyear&quot;<br><span class="hljs-number">4</span>) &quot;1977&quot;<br><span class="hljs-number">5</span>) &quot;verified&quot;<br><span class="hljs-number">6</span>) &quot;1&quot;<br></code></pre></td></tr></table></figure><p>可放入hash的field数量并没有做实际限制，除了物理上可用的内存。</p><p><code>hset,hget,hgetall</code></p><p><code>hmget</code> 可以获取多个field的值</p><p>增加值类型位数值 field 的数值<br><code>hincrby</code></p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>基于哈希表实现的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 添加set元素，创建set</span><br>sadd myset 1 2 3<br>(<span class="hljs-built_in">integer</span>) 3<br><span class="hljs-comment"># 查看myset的元素</span><br>smembers myset<br>1. 3<br>2. 1<br>3. 2<br><span class="hljs-comment"># 判断3是否是myset元素</span><br>sismember myset 3<br>(<span class="hljs-built_in">integer</span>) 1<br>sismember myset 30<br>(<span class="hljs-built_in">integer</span>) 0<br><br><span class="hljs-comment">#创建集合news:1000:tags</span><br>sadd news:1000:tags 1 2 5 77<br>(<span class="hljs-built_in">integer</span>) 4<br><span class="hljs-comment"># 查看news:1000:tags的元素</span><br>smembers news:1000:tags<br><br><br>sadd tag:1:news 1000<br>(<span class="hljs-built_in">integer</span>) 1<br>sadd tag:2:news 1000<br>(<span class="hljs-built_in">integer</span>) 1<br>sadd tag:5:news 1000<br>(<span class="hljs-built_in">integer</span>) 1<br>sadd tag:77:news 1000<br>(<span class="hljs-built_in">integer</span>) 1<br><br><br><span class="hljs-comment">#新建一个52张扑克牌的集合 club, diamond, spade, heart 代表♣️，♦️，♠️，♥️</span><br>sadd deck C1 C2 C3 C4 C5 C6 C7 C8 C9 C10 CJ CQ CK<br>D1 D2 D3 D4 D5 D6 D7 D8 D9 D10 DJ DQ DK H1 H2 H3<br>H4 H5 H6 H7 H8 H9 H10 HJ HQ HK S1 S2 S3 S4 S5 S6<br>S7 S8 S9 S10 SJ SQ SK<br><br><br><span class="hljs-comment">#将deck复制给 game:1:deck</span><br>sunionstore game:1:deck deck<br><br><br><span class="hljs-comment">#获取元素个数</span><br>scard game:1:deck<br><br><span class="hljs-comment">#随机取出一个元素，并删除</span><br>spop game:1:deck<br><br><span class="hljs-comment">#随机获取一个元素，不删除，所以可能多次使用会出现重复的元素</span><br>srandmember game:1:deck<br><br></code></pre></td></tr></table></figure><h2 id="Sorted-Set"><a href="#Sorted-Set" class="headerlink" title="Sorted Set"></a>Sorted Set</h2><h3 id="ZSet数据结构"><a href="#ZSet数据结构" class="headerlink" title="ZSet数据结构"></a>ZSet数据结构</h3><p>有序集合是通过两种数据结构实现的</p><h4 id="压缩列表-ziplist"><a href="#压缩列表-ziplist" class="headerlink" title="压缩列表 ziplist"></a>压缩列表 ziplist</h4><p>ziplist是为了提高存储效率而设计的一种特殊编码的双向链表。它可以存储字符串或者整数，存储整数时是采用整数的二进制而不是字符串形式存储。它能在O(1)的时间复杂度下完成list两端的push和pop操作。但是因为每次操作都需要重新分配ziplist的内存，所以实际复杂度和ziplist的内存使用量相关。</p><h4 id="跳跃表-zSkiplist"><a href="#跳跃表-zSkiplist" class="headerlink" title="跳跃表 zSkiplist"></a>跳跃表 zSkiplist</h4><p>跳跃表的性能可以保证在查找，删除，添加等操作的时候在对数期望时间内完成，这个性能是可以和平衡树来相比较的，而且在实现方面比平衡树要优雅，这是采用跳跃表的主要原因。跳跃表的复杂度是O(log(n))。</p><p>Set中的元素并不是有序的，但是Sorted Set中的每个元素和一个浮点数score相联系，有点像Hash和Set。</p><p>排序规则：<br>（1）如果A.score is &gt; B.score，那么 A&gt;B<br>（2）如果A.score is &#x3D;&#x3D; B.score，那么字典序大的A会A&gt;B</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs bash">zadd &lt;zset_name&gt; score key<br>zadd hackers 1940 <span class="hljs-string">&quot;Alan Kay&quot;</span><br><br><span class="hljs-comment">#也能添加多个entry,形如 score-value的形式</span><br>zadd hackers 1912 <span class="hljs-string">&quot;Alan Turing&quot;</span> 1969 <span class="hljs-string">&quot;Linus Torvalds&quot;</span><br><br><br><span class="hljs-comment">#返回排序的结果，默认是score从小到大</span><br>zrange hackers 0 -1<br><span class="hljs-comment">#Alan Turing</span><br><span class="hljs-comment">#Claude Shannon</span><br><span class="hljs-comment">#Hedy Lamarr</span><br><span class="hljs-comment">#Alan Kay</span><br><span class="hljs-comment">#Sophie Wilson</span><br><span class="hljs-comment">#Linus Torvalds</span><br><br><span class="hljs-comment"># 返回排序结构，并包含数值，出身年份不一定准确，是假数据</span><br>zrange hackers 0 -1 withscores<br>Alan Turing<br>1912<br>Claude Shannon<br>1916<br>Hedy Lamarr<br>1916<br>Alan Kay<br>1940<br>Sophie Wilson<br>1957<br>Linus Torvalds<br>1969<br><br><br><span class="hljs-comment">#也可以逆序排序，实现score从大到小的排序</span><br>zrevrange hackers 0 -1<br><br>zrevrange hackers 0 -1 withscores<br>Linus Torvalds<br>1969<br>Sophie Wilson<br>1957<br>Alan Kay<br>1940<br>Hedy Lamarr<br>1916<br>Claude Shannon<br>1916<br>Alan Turing<br>1912<br></code></pre></td></tr></table></figure><h3 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h3><p>return all the elements with a score between negative infinity and 1950</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gams">&gt; zrangebyscore hackers -<span class="hljs-literal">inf</span> <span class="hljs-number">1950</span><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;Alan Turing&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;Hedy Lamarr&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;Claude Shannon&quot;</span><br><span class="hljs-number">4</span>) <span class="hljs-string">&quot;Alan Kay&quot;</span><br><span class="hljs-number">5</span>) <span class="hljs-string">&quot;Anita Borg&quot;</span><br></code></pre></td></tr></table></figure><h3 id="范围删除"><a href="#范围删除" class="headerlink" title="范围删除"></a>范围删除</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># (1940,1960) ,开区间</span><br>zremrangebyscore hackers 1940 1960<br></code></pre></td></tr></table></figure><h3 id="获得zset中的元素排序"><a href="#获得zset中的元素排序" class="headerlink" title="获得zset中的元素排序"></a>获得zset中的元素排序</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">zrank</span> hackers <span class="hljs-string">&quot;Anita Borg&quot;</span><br></code></pre></td></tr></table></figure><h3 id="字典排序"><a href="#字典排序" class="headerlink" title="字典排序"></a>字典排序</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">zadd hackers 0 <span class="hljs-string">&quot;Alan Kay&quot;</span> 0 <span class="hljs-string">&quot;Sophie Wilson&quot;</span> 0 <span class="hljs-string">&quot;Richard Stallman&quot;</span> 0<br>  <span class="hljs-string">&quot;Anita Borg&quot;</span> 0 <span class="hljs-string">&quot;Yukihiro Matsumoto&quot;</span> 0 <span class="hljs-string">&quot;Hedy Lamarr&quot;</span> 0 <span class="hljs-string">&quot;Claude Shannon&quot;</span><br>  0 <span class="hljs-string">&quot;Linus Torvalds&quot;</span> 0 <span class="hljs-string">&quot;Alan Turing&quot;</span><br><br>zrange hackers 0 -1<br><br><span class="hljs-comment"># zrangebylex </span><br>ZRANGEBYLEX key min max [LIMIT offset count]<br></code></pre></td></tr></table></figure><p>zrangebylex的样例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">redis&gt; ZADD myzset 0 a 0 b 0 c 0 d 0 e 0 f 0 g<br>(<span class="hljs-built_in">integer</span>) 7<br>redis&gt; ZRANGEBYLEX myzset - [c<br>1) <span class="hljs-string">&quot;a&quot;</span><br>2) <span class="hljs-string">&quot;b&quot;</span><br>3) <span class="hljs-string">&quot;c&quot;</span><br>redis&gt; ZRANGEBYLEX myzset - (c<br>1) <span class="hljs-string">&quot;a&quot;</span><br>2) <span class="hljs-string">&quot;b&quot;</span><br>redis&gt; ZRANGEBYLEX myzset [aaa (g<br>1) <span class="hljs-string">&quot;b&quot;</span><br>2) <span class="hljs-string">&quot;c&quot;</span><br>3) <span class="hljs-string">&quot;d&quot;</span><br>4) <span class="hljs-string">&quot;e&quot;</span><br>5) <span class="hljs-string">&quot;f&quot;</span><br></code></pre></td></tr></table></figure><h2 id="BITMAP"><a href="#BITMAP" class="headerlink" title="BITMAP"></a>BITMAP</h2><ul><li>可以实现统计365天用户的登陆天数</li></ul><h1 id="缓存穿透-击穿-雪崩-污染"><a href="#缓存穿透-击穿-雪崩-污染" class="headerlink" title="缓存穿透 击穿 雪崩 污染"></a>缓存穿透 击穿 雪崩 污染</h1><h3 id="穿透"><a href="#穿透" class="headerlink" title="穿透"></a>穿透</h3><p>穿透：redis没有数据，mysql也没有数据</p><ul><li><strong>解决方案</strong></li></ul><h4 id="（1）缓存空值"><a href="#（1）缓存空值" class="headerlink" title="（1）缓存空值"></a>（1）缓存空值</h4><p>   如一个不存在的userID，这个id在缓存和数据库中都不存在，则可以缓存一个空值，下次再查缓存直接返回空值；（防击穿）</p><h4 id="（2）布隆过滤器"><a href="#（2）布隆过滤器" class="headerlink" title="（2）布隆过滤器"></a>（2）布隆过滤器</h4><p>通过bloom filter算法来存储合法key，得益于算法超高的压缩效率，只需占用极小的空间就能存储大量key值。</p><h3 id="击穿"><a href="#击穿" class="headerlink" title="击穿"></a>击穿</h3><p>击穿：redis没有数据，mysql有数据</p><ul><li><strong>现象</strong>：数据key过期，导致多个对同一个key的查询压力给到服务器侧</li><li><strong>解决方案</strong></li></ul><h4 id="（1）接口限流与熔断，降级"><a href="#（1）接口限流与熔断，降级" class="headerlink" title="（1）接口限流与熔断，降级"></a>（1）接口限流与熔断，降级</h4><p>重要的接口一定要做好限流策略，防止用户恶意刷接口，同时要降级准备，当接口中的某些 服务 不可用时候，进行熔断，失败快速返回机制。</p><h4 id="（2）加互斥锁"><a href="#（2）加互斥锁" class="headerlink" title="（2）加互斥锁"></a>（2）加互斥锁</h4><h3 id="雪崩"><a href="#雪崩" class="headerlink" title="雪崩"></a>雪崩</h3><p>很多数据过期，导致查询压力大量给到服务器侧</p><ul><li><strong>解决方案</strong></li></ul><h4 id="（1）分散缓存时间"><a href="#（1）分散缓存时间" class="headerlink" title="（1）分散缓存时间"></a>（1）分散缓存时间</h4><p>将缓存时间分散，比如在原有的实效时间上加一个随机数，例如不同key的过期时间，可以设置为10分1秒过期，10分23秒过期。</p><p>过期时间分散，对于热点数据，过期时间尽量设置得长一点，冷门数据过期时间可以短一点，这样留足够的时间给redis进行数据持久化和主从同步。</p><h4 id="（2）使用缓存集群"><a href="#（2）使用缓存集群" class="headerlink" title="（2）使用缓存集群"></a>（2）使用缓存集群</h4><p>使用缓存集群，避免单机宕机造成的缓存雪崩。</p><h3 id="污染"><a href="#污染" class="headerlink" title="污染"></a>污染</h3><p>指数据只被访问几次，但会长时间驻留在缓存中，消耗缓存空间<br>需要设置key淘汰策略</p><ul><li><strong>解决方案</strong></li></ul><h4 id="（1）分散缓存时间-1"><a href="#（1）分散缓存时间-1" class="headerlink" title="（1）分散缓存时间"></a>（1）分散缓存时间</h4><p>将缓存时间分散，比如在原有的实效时间上加一个随机数，例如不同key的过期时间，可以设置为10分1秒过期，10分23秒过期。</p><p>过期时间分散，对于热点数据，过期时间尽量设置得长一点，冷门数据过期时间可以短一点，这样留足够的时间给redis进行数据持久化和主从同步。</p><h4 id="（2）设置过期策略"><a href="#（2）设置过期策略" class="headerlink" title="（2）设置过期策略"></a>（2）设置过期策略</h4><h2 id="缓存和数据库数据不一致"><a href="#缓存和数据库数据不一致" class="headerlink" title="缓存和数据库数据不一致"></a>缓存和数据库数据不一致</h2><p>4种解决方案<a href="https://coolshell.cn/articles/17416.html">https://coolshell.cn/articles/17416.html</a></p><p>常用的是 <strong>Cache Aside Pattern</strong></p><p>即先修改数据库，再删除缓存；在查询时，将对应的数据设置回redis。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://redis.io/docs/data-types/tutorial/">https://redis.io/docs/data-types/tutorial/</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>负载均衡</title>
    <link href="/system_design/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <url>/system_design/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><h3 id="负载均衡的好处"><a href="#负载均衡的好处" class="headerlink" title="负载均衡的好处"></a>负载均衡的好处</h3><ul><li><p>增加扩展性(increase scalability)</p><p>负载均衡器可以根据服务器的流量峰值来调整（增加或减少）服务器资源</p></li><li><p>冗余(redudant)</p><p>可以为不可避免的硬件故障和服务器宕机提供安全保障</p></li><li><p>可维护性和高性能(maintainability and performance)</p></li></ul><p>具有分布在多个位置和各种云环境的web服务器的业务可以随时安排维护，以提高性能，同时对应用程序正常运行时间的影响最小，因为服务器负载平衡器可以将流量重定向到未进行维护的资源。</p><p>负载均衡常听到<strong>服务端负载均衡</strong>和<strong>客户端负载</strong>均衡，下面分别对比这两个概念。</p><h3 id="SLB-vs-CLB"><a href="#SLB-vs-CLB" class="headerlink" title="SLB vs CLB"></a>SLB vs CLB</h3><h4 id="server-side-load-balancer-SLB"><a href="#server-side-load-balancer-SLB" class="headerlink" title="server side load balancer (SLB)"></a>server side load balancer (SLB)</h4><p>SLB是一个整体，应用于客户端和服务端之间。它接受传入的网络、应用程序流量，并使用各种方法在多个后端服务器之间分配流量。中间的组件负责分发客户端的请求到服务器上。</p><p>优点：初始配置比较容易</p><p>缺点：当应用整体是动态的，即便是hot reload，也很难操作</p><p>例子：nginx, envoy proxy</p><h4 id="client-side-load-balancer"><a href="#client-side-load-balancer" class="headerlink" title="client side load balancer"></a>client side load balancer</h4><p>客户端维护一个服务器ip列表，采取随机等方式选取ip转发请求。</p><p>优点：支持应用服务器动态，当启动时应用会注册它自身</p><p>缺点：初始配置比SLB困难，需要额外的注册服务，例如eureka server，eureka client，ribbon client；因为客户端侧可以知道所有应用服务器，所以也存在<strong>安全</strong>问题</p><p>例子：spring cloud ribbon</p><p>可以看到SLB和CLB技术主要在启动时配置和后续的动态配置上有差异。</p><h3 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h3><p>随机，权重等</p><h3 id="负载均衡相关的应用"><a href="#负载均衡相关的应用" class="headerlink" title="负载均衡相关的应用"></a>负载均衡相关的应用</h3><p>zookeeper，ribbon</p>]]></content>
    
    
    <categories>
      
      <category>系统设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/java/doc-translation/java-lang-ref/"/>
    <url>/java/doc-translation/java-lang-ref/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-Doc-reference翻译"><a href="#Java-Doc-reference翻译" class="headerlink" title="[Java Doc]reference翻译"></a>[Java Doc]reference翻译</h1><p>oracle doc原文：<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/ref/package-summary.html#reachability">https://docs.oracle.com/javase/9/docs/api/java/lang/ref/package-summary.html#reachability</a></p><h1 id="Package-java-lang-ref"><a href="#Package-java-lang-ref" class="headerlink" title="Package java.lang.ref"></a>Package java.lang.ref</h1><p>since: 1.2</p><p>Provides reference-object classes, which support a limited degree of interaction with the garbage collector. A program may use a reference object to maintain a reference to some other object in such a way that the latter object may still be reclaimed by the collector. A program may also arrange to be notified some time after the collector has determined that the reachability of a given object has changed.</p><blockquote><p>提供引用对象类，它们支持同垃圾收集器有限程度的交互。程序可以使用一个引用对象来维护对某个其他对象的引用，利用这样的方式，后一个对象仍然可以被收集器回收。程序也可以安排在收集器确定给定对象的可达性已改变之后，于某个时候得到通知。</p><p>notify v 通知，唤醒</p></blockquote><h2 id="Package-Specification"><a href="#Package-Specification" class="headerlink" title="Package Specification"></a>Package Specification</h2><blockquote><p>包描述</p></blockquote><p>A <em>reference object</em> encapsulates a reference to some other object so that the reference itself may be examined and manipulated like any other object. Three types of reference objects are provided, each weaker than the last: <em>soft</em>, <em>weak</em>, and <em>phantom</em>. Each type corresponds to a different level of reachability, as defined below. Soft references are for implementing memory-sensitive caches, weak references are for implementing canonicalizing mappings that do not prevent their keys (or values) from being reclaimed, and phantom references are for scheduling post-mortem cleanup actions. Post-mortem cleanup actions can be registered and managed by a <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/ref/Cleaner.html"><code>Cleaner</code></a>.</p><blockquote><p>引用对象封装某个其他对象的引用，这使得引用对象本身可以像任何其他对象一样被检查和操作。提供三种引用对象，由从强到弱的顺序是：软引用(soft)，弱引用(*weak)*，虚引用( <em>phantom</em>)。每种类型都对应一个不同的可达度(GC中的可达度)，定义如下。软引用用于实现对内存敏感的缓存，弱引用用于实现不阻止键(或值)被回收的规范化映射，虚引用用于调度事后清理的操作。事后清理行为可以由<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/ref/Cleaner.html">Cleaner</a>对象注册和管理。</p><p>encapsulate v 简述，概括，压缩</p><p>canonicalizing v 规范化</p><p>examine 检查</p></blockquote><p>Each reference-object type is implemented by a subclass of the abstract base <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/ref/Reference.html"><code>Reference</code></a> class. An instance of one of these subclasses encapsulates a single reference to a particular object, called the <em>referent</em>. Every reference object provides methods for getting and clearing the reference. Aside from the clearing operation reference objects are otherwise immutable, so no <code>set</code> operation is provided. A program may further subclass these subclasses, adding whatever fields and methods are required for its purposes, or it may use these subclasses without change.</p><blockquote><p>每个引用对象都由抽象基类 Reference的子类实现。一个这些子类的实例封装了一个对于特定对象的单个引用，这个特定对象被叫做所指对象( <em>referent ,指称</em>)。每种引用对象都提供了获取和清理引用的方法。除了清理操作以外，引用对象是不可变的，所以不提供设置操作。程序可以扩展这些子类出新的子类，出于程序的目的来添加任何字段域(field)和方法(method)，或者不加任何改变来使用这些子类。</p><p>otherwise adv 否则，不然，反之</p><p>immutable adj 不可变</p></blockquote><h3 id="Notification"><a href="#Notification" class="headerlink" title="Notification"></a>Notification</h3><blockquote><p>通知，公示</p></blockquote><p>A program may request to be notified of changes in an object’s reachability by <em>registering</em> an appropriate reference object with a <em>reference queue</em> at the time the reference object is created. Some time after the garbage collector determines that the reachability of the referent has changed to the value corresponding to the type of the reference, it will clear the reference and add it to the associated queue. At this point, the reference is considered to be <em>enqueued</em>. The program may remove references from a queue either by polling or by blocking until a reference becomes available. Reference queues are implemented by the <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/ref/ReferenceQueue.html"><code>ReferenceQueue</code></a> class.</p><blockquote><p>程序可以通过在创建引用对象时，用引用队列注册一个合适的引用对象的方式，来请求通知对象的可达性的变化。在垃圾收集器决定所指对象 (referent) 的可达性变更到相应类型的值后的一段时间，垃圾收集器会清除引用并添加它到关联的队列中。此时，该引用被认为已入队了。程序通过轮询 (poll) 和阻塞 (blocking) 的方式，从队列中删除引用 (reference) ，直到引用 (reference) 变得的再次可达。引用队列由 ReferenceQueue 类实现。</p><p>appropriate adj 合适的，恰当的</p><p>corresponding to 相关的，对应的</p><p>associated 关联的</p><p>either .. or … 两者任一</p></blockquote><p>The relationship between a registered reference object and its queue is one-sided. That is, a queue does not keep track of the references that are registered with it. If a registered reference becomes unreachable itself, then it will never be enqueued. It is the responsibility of the program using reference objects to ensure that the objects remain reachable for as long as the program is interested in their referents.</p><blockquote><p>注册的引用对象和它的队列的关系是片面的。这是因为，队列并不跟踪其注册的引用们(references)。如果一个注册的引用自身变得不可达，之后它将永远不会入队。只要程序还关联引用所指对象(referent)，程序有责任，使用引用来确保对象的可访问性。</p><p>one-sided 片面的</p></blockquote><p>While some programs will choose to <strong>dedicate</strong> a thread to removing reference objects from one or more queues and processing them, this is by no means necessary. A <strong>tactic</strong> that often works well is to <strong>examine</strong> a reference queue in the course of performing some other <strong>fairly</strong>-frequent action. For example, a hashtable that uses weak references to implement weak keys could poll its reference queue each time the table is accessed. This is how the <a href="https://docs.oracle.com/javase/9/docs/api/java/util/WeakHashMap.html"><code>WeakHashMap</code></a> class works. Because the <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/ref/ReferenceQueue.html#poll--"><code>ReferenceQueue.poll</code></a> method simply checks an internal data structure, this check will add little overhead to the hashtable access methods.</p><blockquote><p>虽然一些程序会选择牺牲一个线程从一个或更多的队列删除引用对象和处理它们，但这绝不是必要的。一个通常工作很好的策略，是进行某种相当频繁的操作的时候，检查引用队列。例如，hashtable使用弱引用来实现弱键，当每次访问table的时候，可以轮询它的引用队列。这也是WeakHashMap类的工作原理。因为ReferenceQueue.poll 方法只是检查内部的数据结构，这项检查不会为hashtable访问方法添加额外的开销。</p><p>dedicate 奉献. dedicate&#x2F;devote&#x2F;consecrate sth to doing</p><p>by no means 绝不 this is by no means necessary</p><p>tactic n 策略</p><p>in the course of</p><p>fairly adv quite, considerably 相当地</p></blockquote><h3 id="Automatically-cleared-references"><a href="#Automatically-cleared-references" class="headerlink" title="Automatically-cleared references"></a>Automatically-cleared references</h3><blockquote><p>自动清理的引用们</p></blockquote><p>Soft and weak references are automatically cleared by the collector before being added to the queues with which they are registered, if any. Therefore soft and weak references need not be registered with a queue in order to be useful, while phantom references do. An object that is reachable via phantom references will remain so until all such references are cleared or themselves become unreachable.</p><p>软引用和弱引用在被添加到它们注册的队列中之前，会被垃圾收集器自动清理(如果有的话)。因此为了有效，软引用和弱引用不需要被注册到一个对列中，而虚引用需要添加到队列中。一个可以通过虚引用可达的对象将保持不变，直到所有引用被清除，或者对象自身变得不可达。</p><h3 id="Reachability"><a href="#Reachability" class="headerlink" title="Reachability"></a>Reachability</h3><blockquote><p>可达性</p></blockquote><p>Going from strongest to weakest, the different levels of reachability reflect the life cycle of an object. They are operationally defined as follows:</p><blockquote><p>从最强到最弱，不同可达性的等级反映了一个对象的生命周期。他们操作上被定义为下列：</p><p>operationally adj 操作上</p></blockquote><ul><li>An object is <em>strongly reachable</em> if it can be reached by some thread without traversing any reference objects. A newly-created object is strongly reachable by the thread that created it.</li><li>An object is <em>softly reachable</em> if it is not strongly reachable but can be reached by traversing a soft reference.</li><li>An object is <em>weakly reachable</em> if it is neither strongly nor softly reachable but can be reached by traversing a weak reference. When the weak references to a weakly-reachable object are cleared, the object becomes eligible for finalization.</li><li>An object is <em>phantom reachable</em> if it is neither strongly, softly, nor weakly reachable, it has been finalized, and some phantom reference refers to it.</li><li>Finally, an object is <em>unreachable</em>, and therefore eligible for reclamation, when it is not reachable in any of the above ways.</li></ul><blockquote><ul><li><p>(Strong)如果对象可以被某个线程不用通过任何引用对象访问，这个对象是强可达的。一个新建的对象对于创建它的线程来讲是强可达的。</p></li><li><p>(Soft)如果对象不是强可达，但是可以通过软引用(SoftReference)访问到，它是软可达的。</p></li><li><p>(Weak)如果对象既不是强可达，也不是软可达，但可以通过弱引用(WeakReference)访问到，它是弱可达的。当指向弱引用的弱引用被清除，对象就具备了结束(finalization)的条件。</p></li><li><p>(phantom) 如果对象既不是强可达，软可达，也不是弱可达，对象是虚可达(PhantomReference)。它已经被结束了(finalize)，并且某个虚引用指向它。</p></li><li><p>最终，当对象无法通过上述任何一种方式到达时，对象是不可达状态(unreachable)，因此具备了进行回收的资格。</p></li></ul><p>reclamation n 回收</p></blockquote><h3 id="Interface-Summary"><a href="#Interface-Summary" class="headerlink" title="Interface Summary"></a>Interface Summary</h3><blockquote><p>接口摘要</p></blockquote><table><thead><tr><th>Interface</th><th>Description</th></tr></thead><tbody><tr><td>Cleaner.Cleanable</td><td><code>Cleanable</code> represents an object and a cleaning action registered in a <code>Cleaner</code>.</td></tr><tr><td></td><td><code>Cleanable</code> 表示在 <code>Cleaner</code>上注册的对象和清理工作。注：Cleanable接口只有一个clean()方法。</td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>并发编程 - 解析 ThreadPoolExecutor</title>
    <link href="/java-concurrency-programming/thread-executor/"/>
    <url>/java-concurrency-programming/thread-executor/</url>
    
    <content type="html"><![CDATA[<h2 id="解析ThreadPoolExecutor"><a href="#解析ThreadPoolExecutor" class="headerlink" title="解析ThreadPoolExecutor"></a>解析ThreadPoolExecutor</h2><p>本文通过源码解析 ThreadPoolExecutor，<br>来了解实践中如何设置线程池参数，分析美团线程池实践中如何动态设置线程池参数。</p><h3 id="ThreadPoolExecutor-常用的方法"><a href="#ThreadPoolExecutor-常用的方法" class="headerlink" title="ThreadPoolExecutor 常用的方法"></a>ThreadPoolExecutor 常用的方法</h3><p>Executor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span><br></code></pre></td></tr></table></figure><hr><p>ExecutorService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span>;<br>List&lt;Runnable&gt; <span class="hljs-title function_">shutdownNow</span><span class="hljs-params">()</span>;<br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isShutdown</span><span class="hljs-params">()</span>;<br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isTerminated</span><span class="hljs-params">()</span>;<br><span class="hljs-type">boolean</span> <span class="hljs-title function_">awaitTermination</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span>;<br>Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">()</span>;<br>List&lt;Future&lt;T&gt;&gt; <span class="hljs-title function_">invokeAll</span><span class="hljs-params">()</span>;<br>T <span class="hljs-title function_">invokeAny</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><hr><p>ThreadPoolExecutor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">getPoolSize #线程池的线程数<br>getActiveCount # 活跃线程数<br>getCompletedTaskCount #完成的任务数<br>getQueue().size()  #队列中的任务数<br></code></pre></td></tr></table></figure><h3 id="ThreadPoolExecutor-构造函数"><a href="#ThreadPoolExecutor-构造函数" class="headerlink" title="ThreadPoolExecutor 构造函数"></a>ThreadPoolExecutor 构造函数</h3><p><code>Executors</code>的固定线程池，缓存线程池，单线程池也是通过构造ThreadPoolExecutor对象的方式构造出来的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用给定的初始参数创建一个新的ThreadPoolExecutor。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize, //线程池的核心线程数量</span><br><span class="hljs-params">                              <span class="hljs-type">int</span> maximumPoolSize,//线程池的最大线程数</span><br><span class="hljs-params">                              <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                              //当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span><br><span class="hljs-params">                              TimeUnit unit,//时间单位</span><br><span class="hljs-params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">                              //任务队列，用来储存等待执行任务的队列</span><br><span class="hljs-params">                              ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可</span><br><span class="hljs-params">                              RejectedExecutionHandler handler</span><br><span class="hljs-params">                              //拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span><br><span class="hljs-params">                               )</span> &#123;<br>        <span class="hljs-keyword">if</span> (corePoolSize &lt; <span class="hljs-number">0</span> ||<br>            maximumPoolSize &lt;= <span class="hljs-number">0</span> ||<br>            maximumPoolSize &lt; corePoolSize ||<br>            keepAliveTime &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>        <span class="hljs-keyword">if</span> (workQueue == <span class="hljs-literal">null</span> || threadFactory == <span class="hljs-literal">null</span> || handler == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>        <span class="hljs-built_in">this</span>.corePoolSize = corePoolSize;<br>        <span class="hljs-built_in">this</span>.maximumPoolSize = maximumPoolSize;<br>        <span class="hljs-built_in">this</span>.workQueue = workQueue;<br>        <span class="hljs-built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);<br>        <span class="hljs-built_in">this</span>.threadFactory = threadFactory;<br>        <span class="hljs-built_in">this</span>.handler = handler;<br>    &#125;<br></code></pre></td></tr></table></figure><p>使用阿里巴巴推荐的创建线程池的方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CORE_POOL_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_POOL_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">QUEUE_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Long</span> <span class="hljs-variable">KEEP_ALIVE_TIME</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;    <br><br><span class="hljs-comment">//通过ThreadPoolExecutor构造函数自定义参数创建</span><br><span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>  CORE_POOL_SIZE,<br>  MAX_POOL_SIZE,<br>  KEEP_ALIVE_TIME,<br>  TimeUnit.SECONDS,<br>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(QUEUE_CAPACITY),<br>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());<br><br></code></pre></td></tr></table></figure><p><code>ThreadPoolExecutor</code> 3 个最重要的参数：</p><ul><li><code>corePoolSize</code> : 核心线程数线程数定义了最小可以同时运行的线程数量。</li><li><code>maximumPoolSize</code> :  最大池数量，注意：实际最大值在内部由 CAPACITY 限制</li><li><code>workQueue</code>: 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li></ul><p><code>ThreadPoolExecutor</code>其他常见参数:</p><ol><li><code>keepAliveTime</code>:当线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁；</li><li><code>unit</code> : <code>keepAliveTime</code> 参数的时间单位。</li><li><code>threadFactory</code> :executor 创建新线程的时候会用到。</li><li><code>handler</code> :饱和策略。关于饱和策略下面单独介绍一下。</li></ol><p><code>ThreadPoolExecutor</code> 饱和策略定义:</p><p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，<code>ThreadPoolTaskExecutor</code> 定义一些策略:</p><ul><li><code>ThreadPoolExecutor.AbortPolicy</code>：抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。默认是该策略</li><li><code>ThreadPoolExecutor.CallerRunsPolicy</code>：调用执行自己的线程运行任务。您不会任务请求。但是这种策略会降低对于新任务提交速度，影响程序的整体性能。另外，这个策略喜欢增加队列容量。对于可伸缩的应用程序，如果您的应用程序可以承受此延迟并且你不能任务丢弃任何一个任务请求的话，你可以选择这个策略。</li><li><code>ThreadPoolExecutor.DiscardPolicy</code>：不处理新任务，直接丢弃掉。</li><li><code>ThreadPoolExecutor.DiscardOldestPolicy</code>： 此策略将丢弃最早的未处理的任务请求。</li></ul><h3 id="设置线程池名称"><a href="#设置线程池名称" class="headerlink" title="设置线程池名称"></a>设置线程池名称</h3><p>为了便于定位问题，线程池在实践中应当命名。</p><ol><li>利用 <code>ThreadFactoryBuilder</code></li></ol><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ThreadFactory</span> <span class="hljs-variable">threadFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadFactoryBuilder</span>()<br>                        .setNameFormat(threadNamePrefix + <span class="hljs-string">&quot;-%d&quot;</span>)<br>                        .setDaemon(<span class="hljs-literal">true</span>).build();<br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(corePoolSize, maximumPoolSize, keepAliveTime, TimeUnit.MINUTES, workQueue, threadFactory)<br></code></pre></td></tr></table></figure><ol start="2"><li>自己实现 <code>ThreadFactory</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><span class="hljs-keyword">import</span> java.util.concurrent.ThreadFactory;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 线程工厂，它设置线程名称，有利于我们定位问题。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NamingThreadFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ThreadFactory</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">threadNum</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ThreadFactory delegate;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建一个带名字的线程池生产工厂</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NamingThreadFactory</span><span class="hljs-params">(ThreadFactory delegate, String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.delegate = delegate;<br>        <span class="hljs-built_in">this</span>.name = name; <span class="hljs-comment">// TODO consider uniquifying this</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span> <br>    <span class="hljs-keyword">public</span> Thread <span class="hljs-title function_">newThread</span><span class="hljs-params">(Runnable r)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> delegate.newThread(r);<br>        t.setName(name + <span class="hljs-string">&quot; [#&quot;</span> + threadNum.incrementAndGet() + <span class="hljs-string">&quot;]&quot;</span>);<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h3><p>源码中runState和workerCount维护是放在一起的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">ctl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="hljs-number">0</span>));<br></code></pre></td></tr></table></figure><p>ctl的高3位保存runState，低29位保存workerCount</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">runStateOf</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>     &#123; <span class="hljs-keyword">return</span> c &amp; ~CAPACITY; &#125; <span class="hljs-comment">//计算当前运行状态</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">workerCountOf</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>  &#123; <span class="hljs-keyword">return</span> c &amp; CAPACITY; &#125;  <span class="hljs-comment">//计算当前线程数量</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ctlOf</span><span class="hljs-params">(<span class="hljs-type">int</span> rs, <span class="hljs-type">int</span> wc)</span> &#123; <span class="hljs-keyword">return</span> rs | wc; &#125;   <span class="hljs-comment">//通过状态和线程数生成ctl</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>运行状态</th><th>状态描述</th></tr></thead><tbody><tr><td>running</td><td>能接受新提交的任务，并能处理阻塞队列中的任务。</td></tr><tr><td>Shutdown</td><td>关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务。</td></tr><tr><td>Stop</td><td>不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。</td></tr><tr><td>Tidying</td><td>所有任务都终止了，workerCount为0</td></tr><tr><td>Terminated</td><td>在terminated() 方法执行完成后进入该状态</td></tr></tbody></table><p><img src="/java-concurrency-programming/thread-executor/lifecyc-thread-pool.png" alt="lifecyc-thread-pool"></p><h3 id="任务调度过程"><a href="#任务调度过程" class="headerlink" title="任务调度过程"></a>任务调度过程</h3><ol><li>首先检测线程池运行状态，如果不是RUNNING，则直接拒绝，线程池要保证在RUNNING的状态下执行任务。</li><li>如果workerCount &lt; corePoolSize，则创建并启动一个线程来执行新提交的任务。</li><li>如果workerCount &gt;&#x3D; corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中。</li><li>如果workerCount &gt;&#x3D; corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务。</li><li>如果workerCount &gt;&#x3D; maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。</li></ol><p>阻塞队列</p><p><img src="/java-concurrency-programming/thread-executor/thread-block-queue.png" alt="thread-block-queue.png"></p><h3 id="线程池核心问题：设置参数"><a href="#线程池核心问题：设置参数" class="headerlink" title="线程池核心问题：设置参数"></a>线程池核心问题：设置参数</h3><p>ThreadPoolExecutor主要有7个参数</p><ol><li><p><strong>corePoolSize</strong>：the number of threads to keep in the pool, even if they are idle, unless {@code allowCoreThreadTimeOut} is set</p><p>（核心线程数大小：不管它们创建以后是不是空闲的。线程池需要保持 corePoolSize 数量的线程，除非设置了 allowCoreThreadTimeOut。）</p></li><li><p><strong>maximumPoolSize</strong>：the maximum number of threads to allow in the pool。</p><p>（最大线程数：线程池中最多允许创建 maximumPoolSize 个线程。）</p></li><li><p><strong>keepAliveTime</strong>：when the number of threads is greater than the core, this is the maximum time that excess idle threads will wait for new tasks before terminating。</p><p>（存活时间：如果经过 keepAliveTime 时间后，超过核心线程数的线程还没有接受到新的任务，那就回收。）</p></li><li><p><strong>unit：</strong>the time unit for the {@code keepAliveTime} argument</p><p>（keepAliveTime 的时间单位。）</p></li><li><p><strong>workQueue</strong>：the queue to use for holding tasks before they are executed.  This queue will hold only the {@code Runnable} tasks submitted by the {@code execute} method。</p><p>（存放待执行任务的队列：当提交的任务数超过核心线程数大小后，再提交的任务就存放在这里。它仅仅用来存放被 execute 方法提交的 Runnable 任务。所以这里就不要翻译为工作队列了，好吗？不要自己给自己挖坑。）</p></li><li><p><strong>threadFactory</strong>：the factory to use when the executor creates a new thread。</p><p>（线程工程：用来创建线程工厂。比如这里面可以自定义线程名称，当进行虚拟机栈分析时，看着名字就知道这个线程是哪里来的，不会懵逼。）</p></li><li><p><strong>handler</strong> ：the handler to use when execution is blocked because the thread bounds and queue capacities are reached。</p><p>（拒绝策略：当队列里面放满了任务、最大线程数的线程都在工作时，这时继续提交的任务线程池就处理不了，应该执行怎么样的拒绝策略。）</p></li></ol><p>其中最重要的是3个参数：corePoolSize，maximumPoolSize，workQueue</p><h4 id="corePoolSize"><a href="#corePoolSize" class="headerlink" title="corePoolSize"></a>corePoolSize</h4><p>有一个简单并且适用面比较广的公式：</p><ul><li><p><strong>CPU 密集型任务(N+1)：</strong> 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。(《Java并发编程实战》中的解释)</p></li><li><p><strong>I&#x2F;O 密集型任务(2N)：</strong> 这种任务应用起来，系统会用大部分的时间来处理 I&#x2F;O 交互，而线程在处理 I&#x2F;O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I&#x2F;O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</p></li></ul><p>获取处理器逻辑核心数量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">N_CPUS</span> <span class="hljs-operator">=</span> Runtime.getRuntime().availableProcessors();<br></code></pre></td></tr></table></figure><p><strong>如何判断是 CPU 密集任务还是 IO 密集任务？</strong></p><p>CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。</p><p>但凡涉及到网络读取，文件读取这类都是 IO 密集型，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。</p><p>美团在实践中提出了将线程池参数动态化的方式</p><h4 id="线程池预热"><a href="#线程池预热" class="headerlink" title="线程池预热"></a>线程池预热</h4><p>线程池被创建后如果没有任务过来，里面是不会有线程的。如果需要预热的话可以调用下面的两个方法</p><p>第一个是全启动</p><p>第二个是仅启动一个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Starts all core threads, causing them to idly wait for work. This</span><br><span class="hljs-comment"> * overrides the default policy of starting core threads only when</span><br><span class="hljs-comment"> * new tasks are executed.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the number of threads started</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">prestartAllCoreThreads</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>))<br>        ++n;<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Starts a core thread, causing it to idly wait for work. This</span><br><span class="hljs-comment"> * overrides the default policy of starting core threads only when</span><br><span class="hljs-comment"> * new tasks are executed. This method will return &#123;<span class="hljs-doctag">@code</span> false&#125;</span><br><span class="hljs-comment"> * if all core threads have already been started.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@code</span> true&#125; if a thread was started</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">prestartCoreThread</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> workerCountOf(ctl.get()) &lt; corePoolSize &amp;&amp;<br>        addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="核心线程数会被回收吗"><a href="#核心线程数会被回收吗" class="headerlink" title="核心线程数会被回收吗"></a>核心线程数会被回收吗</h4><p>核心线程数默认不会被回收。</p><p>线程池中线程的销毁依赖JVM自动的回收，线程池做的工作是根据当前线程池的状态维护一定数量的线程引用，防止这部分线程被JVM回收，当线程池决定哪些线程需要回收时，只需要将其引用消除即可。Worker被创建出来后，就会不断地进行轮询，然后获取任务去执行，核心线程可以无限等待获取任务，非核心线程要限时获取任务。当Worker无法获取到任务，也就是获取的任务为空时，循环会结束，<strong>Worker会主动消除自身在线程池内的引用</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-keyword">while</span> (task != <span class="hljs-literal">null</span> || (task = getTask()) != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">//执行任务</span><br>  &#125;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>  processWorkerExit(w, completedAbruptly);<span class="hljs-comment">//获取不到任务时，主动回收自己</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/java-concurrency-programming/thread-executor/thread-collect.png" alt="thread-collect.png"></p><p>如需回收核心线程数，需要调用下面的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Sets the policy governing whether core threads may time out and</span><br><span class="hljs-comment">     * terminate if no tasks arrive within the keep-alive time, being</span><br><span class="hljs-comment">     * replaced if needed when new tasks arrive. When false, core</span><br><span class="hljs-comment">     * threads are never terminated due to lack of incoming</span><br><span class="hljs-comment">     * tasks. When true, the same keep-alive policy applying to</span><br><span class="hljs-comment">     * non-core threads applies also to core threads. To avoid</span><br><span class="hljs-comment">     * continual thread replacement, the keep-alive time must be</span><br><span class="hljs-comment">     * greater than zero when setting &#123;<span class="hljs-doctag">@code</span> true&#125;. This method</span><br><span class="hljs-comment">     * should in general be called before the pool is actively used.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value &#123;<span class="hljs-doctag">@code</span> true&#125; if should time out, else &#123;<span class="hljs-doctag">@code</span> false&#125;</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IllegalArgumentException if value is &#123;<span class="hljs-doctag">@code</span> true&#125;</span><br><span class="hljs-comment">     *         and the current keep-alive time is not greater than zero</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span> 1.6</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">allowCoreThreadTimeOut</span><span class="hljs-params">(<span class="hljs-type">boolean</span> value)</span> &#123;<br>        <span class="hljs-keyword">if</span> (value &amp;&amp; keepAliveTime &lt;= <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Core threads must have nonzero keep alive times&quot;</span>);<br>        <span class="hljs-keyword">if</span> (value != allowCoreThreadTimeOut) &#123;<br>            allowCoreThreadTimeOut = value;<br>            <span class="hljs-keyword">if</span> (value)<br>                interruptIdleWorkers();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">美团线程池实践</a></p>]]></content>
    
    
    <categories>
      
      <category>concurrency</category>
      
    </categories>
    
    
    <tags>
      
      <tag>concurrency</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发编程 - 线程池 Thread Pool</title>
    <link href="/java-concurrency-programming/thread-pool/"/>
    <url>/java-concurrency-programming/thread-pool/</url>
    
    <content type="html"><![CDATA[<p>本文介绍了Java中的几种线程池，及Executors构造线程池的用法。</p><h2 id="Java-线程池-Thread-Pool"><a href="#Java-线程池-Thread-Pool" class="headerlink" title="Java 线程池 Thread Pool"></a>Java 线程池 Thread Pool</h2><p>构建新线程的开销较大。如果程序中需要创建大量很短生命期的线程，应该使用<strong>线程池</strong>，而不是将每个任务映射到一个单独线程。</p><p>线程池中包含很多准备运行的线程，每为线程池提供一个Runnable实例，就会有一个池中的线程调用run方法。当run方法退出时，这个线程不会死亡，而是留在池中准备为下一个请求 (Runnable实例) 提供服务。</p><h3 id="执行器-Executors"><a href="#执行器-Executors" class="headerlink" title="执行器 Executors"></a>执行器 Executors</h3><p>执行器有许多静态工厂方法，用来构造线程池。<br>静态工厂方法返回类型为 <code>ExecutorService</code></p><center> 表格 Executors工厂方法 </center><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>newCachedThreadPool</td><td>必要时创建新线程；空闲线程会保留60 s</td></tr><tr><td>newFixedThreadPool</td><td>池中包含固定数目的线程；空闲线程会一直保留</td></tr><tr><td>newWorkStealingPool</td><td>一种适合“fork-join”任务的线程池，其中复杂的任务会分解为更简单的任务，空闲线程会“密取”较简单的任务</td></tr><tr><td>newSingleThreadExecutor</td><td>只有一个线程的“池”，会顺序地执行所提交的任务</td></tr><tr><td>newScheduledThreadPool</td><td>用于调度执行的固定线程池</td></tr><tr><td>newSingleThreadScheduledExecutor</td><td>用于调度执行的单线程池</td></tr></tbody></table><h4 id="缓存线程池-newCachedThreadPool"><a href="#缓存线程池-newCachedThreadPool" class="headerlink" title="缓存线程池 newCachedThreadPool"></a>缓存线程池 newCachedThreadPool</h4><p>构造一个线程池，会立即执行各个任务。如果有空闲线程可用，就使用现有空闲线程执行任务；如果没有可用的空闲线程，则创建一个新线程。</p><h4 id="固定线程池-newFixedThreadPool"><a href="#固定线程池-newFixedThreadPool" class="headerlink" title="固定线程池 newFixedThreadPool"></a>固定线程池 newFixedThreadPool</h4><p>构造一个固定大小的线程池。如果提交的任务数多于空闲线程数，就把未得到服务的任务放到队列中。当其他任务完成以后再运行这些排队的任务。</p><h4 id="单线程池-newSingleThreadExecutor"><a href="#单线程池-newSingleThreadExecutor" class="headerlink" title="单线程池 newSingleThreadExecutor"></a>单线程池 newSingleThreadExecutor</h4><p>是一个退化了的大小为1的线程池：由一个线程顺序地执行所提交的任务（顺序执行）。</p><p>参考上面的 FixedThreadPool</p><h4 id="使用线程池的小结"><a href="#使用线程池的小结" class="headerlink" title="使用线程池的小结"></a>使用线程池的小结</h4><p>如果线程生存时间很短，或者大量时间都在阻塞，业务是轻量负载的，可以使用<strong>缓存线程池</strong>。</p><p><strong>为了获得最优的运行速度</strong>，业务是高负载的，可以令并发线程数等于处理内核数(查看CPU内核数方法见下文)。在这种情况下，就应该使用<strong>固定线程池</strong>，即并发线程总数有一个上限。</p><p><strong>单线程池</strong>对于<strong>性能分析</strong>很有帮助。如临时使用一个单线程池替换其他线程池，就能测量不适用并发的情况下应用的运行速度会慢多少。</p><p>实际使用的时候推荐自己创建<code>ThreadPoolExecutor</code> (避免OOM)</p><blockquote><p>Executors 返回线程池对象的弊端如下：</p><ul><li><code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code>： 允许请求的队列长度为 &gt; <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li><li><code>CachedThreadPool </code>和<code> ScheduledThreadPool</code> ： 允许创建的线程数量为 &gt; <code>Integer.MAX_VALUE</code> ，可能会创建大量线程，从而导致 OOM。</li></ul></blockquote><p>综合来讲，因为队列上限和创建线程上限，导致OOM发生。</p><p>除了避免 OOM 的原因之外，不推荐使用 <code>Executors </code>提供的两种快捷的线程池的原因还有：</p><ol><li>实际使用中需要根据自己机器的性能、业务场景来手动配置线程池的参数比如核心线程数、使用的任务队列、饱和策略等等。</li><li>我们应该显示地给我们的线程池命名，这样有助于我们定位问题。</li></ol><h5 id="如何查看CPU内核数量"><a href="#如何查看CPU内核数量" class="headerlink" title="如何查看CPU内核数量"></a>如何查看CPU内核数量</h5><p>Linux: <code>cat /proc/cpuinfo| grep &quot;cpu cores&quot;| uni</code></p><p>Mac: 查看物理内核 <code>sysctl hw.physicalcpu</code></p><p>逻辑内核 <code>sysctl hw.logicalcpu</code></p><hr><h3 id="ExecutorService分析"><a href="#ExecutorService分析" class="headerlink" title="ExecutorService分析"></a>ExecutorService分析</h3><p>上文中的几种线程池都属于<code>ThreadPoolExecutor</code>类，实现了<code>ExecutorService</code>的接口。</p><center>图 ExecutorService 继承关系</center><img src="executorService.png" alt="executorService" style="zoom: 67%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span>;<br>Future&lt;?&gt; submit(Runnable task);<br>Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Runnable task, T result)</span>;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span>;<br>List&lt;Runnable&gt; <span class="hljs-title function_">shutdownNow</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><p>调用submit时，会得到<strong>Future</strong>对象，可用来得到结果(get)或者取消任务(cancel)。</p><p>第二个submit返回的<strong>Future</strong>对象可以来调用isDone, cancel, isCancelled。但是get方法在完成的时候只是简单返回null。</p><p>第三个submit也生成一个<strong>Future</strong>，它的get方法在完成的时候返回指定的result对象。</p><p>shutdown 用于关闭线程池，被关闭的线程池不再接受新任务，当所有任务完成时，线程池中的线程死亡。</p><p>shutdownNow 会取消所有尚未开始的任务。</p><hr><h3 id="fork-join框架"><a href="#fork-join框架" class="headerlink" title="fork-join框架"></a>fork-join框架</h3><p>有一些应用可能对处理器内核分别使用一个线程，以完成计算密集型任务，如图像或视频处理的应用。Java 7 中新引入了fork-join框架，专门用来支持这一类应用。</p><p>假设有一个处理任务，它可以很自然地分解为子任务，如下所示</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">if</span> problemSize &lt; threshold<br>solve problem directly<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">break</span> problem <span class="hljs-keyword">into</span> subproblems<br>recursively solve <span class="hljs-keyword">each</span> subproblem<br>conbine the results<br>&#125;<br></code></pre></td></tr></table></figure><p>为了完成这种递归计算，需要提供扩展<code>RecursiveTask&lt;T&gt;</code>的类或者提供扩展<code>RecursiveAction&lt;T&gt;</code>的类。再覆盖compute方法来生成并调用子任务。</p><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecursiveTask</span>&lt;Integer&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">THRESHOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> to, from;<br>    <span class="hljs-keyword">private</span> DoublePredicate filter;<br>    <span class="hljs-type">int</span>[] values;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Counter</span><span class="hljs-params">(<span class="hljs-type">int</span>[] numbers, <span class="hljs-type">int</span> from, <span class="hljs-type">int</span> to, DoublePredicate filter)</span> &#123;<br>        <span class="hljs-built_in">this</span>.values = numbers;<br>        <span class="hljs-built_in">this</span>.from = from;<br>        <span class="hljs-built_in">this</span>.to = to;<br>        <span class="hljs-built_in">this</span>.filter = filter;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (to - from &lt; THRESHOLD) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> from; i &lt; to; i++) &#123;<br>                <span class="hljs-keyword">if</span> (filter.test(values[i])) count++;<br>            &#125;<br>            <span class="hljs-keyword">return</span> count;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (to + from) / <span class="hljs-number">2</span>;<br>            <span class="hljs-type">Counter</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Counter</span>(values, from, mid, filter);<br>            <span class="hljs-type">Counter</span> <span class="hljs-variable">second</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Counter</span>(values, mid, to, filter);<br>            invokeAll(first, second);<br>            <span class="hljs-keyword">return</span> first.join() + second.join();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在后台，fork-join采用了一种有效的智能方法来平衡可用线程的工作负载，这种方法称为工作密取(work-stealing)。一个工作线程将子任务压入双端队列的队头(只有一个线程可以访问队头，故可以不加锁)，另一个工作线程空闲时，它会从双端队列的队尾“密取”一个任务。</p><blockquote><p>⚠️警告: fork-join池是针对非阻塞工作负载优化的。如果向一个fork-join池增加很多阻塞任务，会使其无法有效工作。</p></blockquote><h3 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h3><p><a href="http://fuheihei.github.io/java-concurrency-programming/thread-executor">解析ThreadPoolExecutor</a></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg3NjU3NTkwMQ==&mid=2247505103&idx=1&sn=a041dbec689cec4f1bbc99220baa7219&source=41#wechat_redirect">如何设置线程池参数？美团给出了一个让面试官虎躯一震的回答  作者: why技术</a></p>]]></content>
    
    
    <categories>
      
      <category>concurrency</category>
      
    </categories>
    
    
    <tags>
      
      <tag>concurrency</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何写博客</title>
    <link href="/tools/how-to-write-blog/"/>
    <url>/tools/how-to-write-blog/</url>
    
    <content type="html"><![CDATA[<p>我建立博客的初心是记录技术，并将自己在编程中学到的知识，写成规范的文档形式。</p><p>将自己学会的技术写成文档的过程，类似于嚼饭给别人吃，如果自己的积累不到位，饭就嚼得不好。</p><p>需要作者本身尽力做到内容对自己对他人都是有帮助的。</p><h3 id="1-文档工具"><a href="#1-文档工具" class="headerlink" title="1. 文档工具"></a>1. 文档工具</h3><p>博客文章格式还是markdown为主</p><h3 id="2-markdown写作规范"><a href="#2-markdown写作规范" class="headerlink" title="2. markdown写作规范"></a>2. markdown写作规范</h3><p>写作规范详细参考github上的 <a href="https://github.com/fex-team/styleguide/blob/master/markdown.md">Markdown 编写规范-中文</a></p><h3 id="3-字体"><a href="#3-字体" class="headerlink" title="3. 字体"></a>3. 字体</h3><p>编写博客过程中需要用到不同的字体颜色，来标识不同重要程度的内容。</p><p>正常字体是默认的黑色，下列提供可供参考配色的颜色设计网站</p><p><a href="https://flatuicolors.com/palette/defo">1 - FlatUI 配色</a></p><p><a href="https://ant.design/docs/spec/colors-cn#%E5%9C%A8%E4%BB%A3%E7%A0%81%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%89%B2%E6%9D%BF">2 - Ant Design 配色</a></p><p><span style="color:#fe6673">红色 #fe6673 </span> 重要的内容</p><p><span style="color:#3498db">蓝色 #3498db</span> 新名词首次出现</p><p><span style="color:#f1c40f">黄色 #f1c40f</span> warning警告相关的颜色</p><p><span style="color:#27ae60">绿色 #27ae60</span> 论证过程，或者过程性质的代码</p><p>如下所示，在md中嵌入html标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:...&quot;</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> <span class="hljs-comment">&lt;!--用标签包裹需要上色的文字--&gt;</span><br></code></pre></td></tr></table></figure><h3 id="4-代码样式"><a href="#4-代码样式" class="headerlink" title="4. 代码样式"></a>4. 代码样式</h3><p>博客中的代码部分格式以markdown样式为主，分为大的代码块（带行号）和普通代码行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">hello world <span class="hljs-comment">//代码块</span><br></code></pre></td></tr></table></figure><p><code>hello world</code> 普通代码行</p><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><p>每天进步一点点，保持笔记的清晰有条理。</p>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>个人博客搭建</title>
    <link href="/tools/how-to-build-my-blog/"/>
    <url>/tools/how-to-build-my-blog/</url>
    
    <content type="html"><![CDATA[<p>搭建个人博客 hexo+kaze+gitalk。</p><p>我们经常会看到github有人有<code>&lt;username&gt;.github.io</code>形式的个人博客网页，他们是怎么做到的呢？</p><p>仔细观察，不少人的博客底部还会出现 “powered by hexo” 或者 “由hexo强力驱动” 的字样</p><p>通过下文，你也可以搭建一个自己的github pages博客</p><h2 id="1-Github-Pages"><a href="#1-Github-Pages" class="headerlink" title="1.Github Pages"></a>1.Github Pages</h2><p>没错，浏览器中url为<code>&lt;username&gt;.github.io</code>形式的博客是github提供的一种博客功能，这个功能叫做github pages。<br>当用户在github上新建了<code>&lt;username&gt;.github.io</code>的public的仓库(<code>&lt;username&gt;</code>和自己的github用户名一致)，就可以为自己生成对应的github pages。并且其他访客可以通过这个url访问你的博客。</p><h2 id="2-hexo项目构建"><a href="#2-hexo项目构建" class="headerlink" title="2. hexo项目构建"></a>2. hexo项目构建</h2><h3 id="2-1用-hexo初始化项目"><a href="#2-1用-hexo初始化项目" class="headerlink" title="2.1用 hexo初始化项目"></a>2.1用 hexo初始化项目</h3><p>第一步，安装hexo</p><p>通过hexo-cli的方式，构建博客项目会更容易。</p><p>环境：需要git，node环境(&gt;&#x3D;12.0.0, 推荐nvm安装node)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-cli -g<br></code></pre></td></tr></table></figure><p>详细安装配置可以看<a href="https://hexo.io/zh-cn/docs/">hexo官网文档 </a><br>(简便安装上面一行指令就够了)</p><p>第二步，接着hexo在本地构建项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init &lt;project_url&gt; <span class="hljs-comment">#初始化项目</span><br><span class="hljs-built_in">cd</span> &lt;project_url&gt; <span class="hljs-comment">#进入项目路径</span><br></code></pre></td></tr></table></figure><p>常用的hexo指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo g <span class="hljs-comment">#即 hexo generate，生成静态文件</span><br>hexo s <span class="hljs-comment">#即 hexo server，本地运行服务器</span><br>hexo d <span class="hljs-comment">#即 hexo deploy，部署服务器，常用指令 hexo clean &amp;&amp; hexo d</span><br></code></pre></td></tr></table></figure><h3 id="2-2-新建github-pages-仓库"><a href="#2-2-新建github-pages-仓库" class="headerlink" title="2.2 新建github pages 仓库"></a>2.2 新建github pages 仓库</h3><p>新建一个github项目，项目名为&#96;&#96;{username}<code>.github.io</code>，项目是public的而非private的。</p><p>修改本地hexo项目根目录下的 _config.yml文件，添加 deploy 相关的属性。</p><p>需要指定发布项目的repo，这里因为我们用的是github pages，github pages通常是<code> &#123;username&#125;</code>.github.io&#96;形式的public仓库。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Deployment</span><br><span class="hljs-comment">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">git@github.com:fuheihei/fuheihei.github.io.git</span> <span class="hljs-comment"># 指定为你的github pages的git地址</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">main</span> <span class="hljs-comment">#对应的git分支</span><br></code></pre></td></tr></table></figure><h2 id="3-博客主题的选取"><a href="#3-博客主题的选取" class="headerlink" title="3.博客主题的选取"></a>3.博客主题的选取</h2><p>hexo构建的博客项目可以选取很多开源的hexo主题，类似于qq空间的皮肤，我们通过修改根目录下<code>_config.yml</code>中的属性<code>theme: </code>就能指定对应的皮肤。</p><p>例如</p><p>想要选择的主题是<a href="https://github.com/Ben02/hexo-theme-Anatole">anatole</a></p><p>将主题项目 <code>git clone</code> 到项目中的themes文件夹下，修改项目根目录下的<code>_config.yml</code>中的属性</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">theme: anatole  <span class="hljs-comment">#将theme指定为anatole</span><br><span class="hljs-comment"># Extensions</span><br><span class="hljs-comment">## Plugins: https://hexo.io/plugins/</span><br><span class="hljs-comment">## Themes: https://hexo.io/themes/</span><br></code></pre></td></tr></table></figure><p>需要注意的是，如果指定为anatole，那么项目必须得有theme&#x2F;anatole文件夹。</p><p>其他丰富的hexo主题请查阅: <a href="https://hexo.io/themes/">https://hexo.io/themes/</a></p><h2 id="4-写文章"><a href="#4-写文章" class="headerlink" title="4.写文章"></a>4.写文章</h2><h3 id="4-1-新建文章"><a href="#4-1-新建文章" class="headerlink" title="4.1 新建文章"></a>4.1 新建文章</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new [layout] &lt;title文章名&gt;<br></code></pre></td></tr></table></figure><p>例如 <code>hexo new post how-to-build-my-blog</code></p><p><code>[layout]</code>可以是 post、page 和 draft，其位置和source&#x2F;_post，source&#x2F;page，source&#x2F;_draft是相关联的。</p><h3 id="4-2-发布文章"><a href="#4-2-发布文章" class="headerlink" title="4.2 发布文章"></a>4.2 发布文章</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo g <span class="hljs-comment">#即 hexo generate，生成静态文件</span><br>hexo s <span class="hljs-comment">#即 hexo server，本地运行服务器</span><br>hexo d <span class="hljs-comment">#即 hexo deploy，部署服务器，也可以用指令 hexo clean &amp;&amp; hexo d</span><br></code></pre></td></tr></table></figure><p>hexo d可以将本地的hexo 项目转换成github pages需要的项目发布在你的github repo中，在浏览器输入 <code>&lt;username&gt;.github.io</code> 就能看到和本地一样的hexo博客了。</p><h2 id="5-评论系统"><a href="#5-评论系统" class="headerlink" title="5.评论系统"></a>5.评论系统</h2><p>完善的博客还应该提供访问用户讨论的机会。</p><img src="comments.png" alt="gitalk的demo图" width="80%" height="80%"><p></p><p style="text-align:center">gitalk的demo图</p><p>评论系统有很多，出于免费和效率考虑，此处使用gitalk</p><p>gitalk是github提供的评论系统，免费；同时gitalk的用户评论文章的内容可以在repo生成对应的issues，可以起到邮件通知的效果，保证及时回复用户。</p><h3 id="1-申请OAuth-Apps"><a href="#1-申请OAuth-Apps" class="headerlink" title="(1)申请OAuth Apps"></a>(1)申请OAuth Apps</h3><p>在github -&gt; settings -&gt; Developer Settings -&gt; OAuth Apps 中申请新的OAuth项目。</p><p><code>Authorization callback URL</code> 和 <code>Homepage URL</code> 属性都写<code>&lt;username&gt;</code>.github.io博客的地址。</p><p>并点击按钮，生成 clientSecret，下面会用到。</p><h3 id="2-填写gitalk的属性"><a href="#2-填写gitalk的属性" class="headerlink" title="(2)填写gitalk的属性"></a>(2)填写gitalk的属性</h3><p>修改项目中的<code>_config.yml</code>文件，我的在<code>theme/hexo-theme-Kaze/_config.yml</code>中。修改对应gitalk配置的部分。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">gitalk:</span><br>  <span class="hljs-attr">clientID:</span> <span class="hljs-string">&lt;clientID&gt;</span><br>  <span class="hljs-attr">clientSecret:</span> <span class="hljs-string">&lt;clientSecret&gt;</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">fuheihei.github.io</span><br>  <span class="hljs-attr">owner:</span> <span class="hljs-string">fuheihei</span><br>  <span class="hljs-attr">admin:</span> <span class="hljs-string">fuheihei</span><br>  <span class="hljs-attr">id:</span> <span class="hljs-string">location.href</span> <span class="hljs-comment"># dont modify</span><br>  <span class="hljs-attr">distractionFreeMode:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">language:</span> <span class="hljs-string">navigator.language</span> <span class="hljs-string">||</span> <span class="hljs-string">navigator.userLanguage</span><br>  <span class="hljs-attr">labels:</span> [<span class="hljs-string">&#x27;Gitalk&#x27;</span>]<br>  <span class="hljs-attr">perPage:</span> <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><h2 id="6-发布博客"><a href="#6-发布博客" class="headerlink" title="6.发布博客"></a>6.发布博客</h2><p>本地测试查看无误后，使用命令<code>hexo clean &amp;&amp; hexo deploy</code>可以上传change提交到<code>&#123;username&#125;</code>.github.io项目中。</p><p>提交结果如下图所示</p><img src='gitlog-commit.png' alt="提交记录demo图" width="80%" height="80%"><p style="text-align:center">提交记录demo图</p><p>可以看到<code>hexo deploy</code>指令会自动生成git的提交到repo上，通常是以时间作为commit的message。</p><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><p>经过上述的步骤，相信你也会有一个较好的博客了，接下来开始享受写作吧！</p>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
