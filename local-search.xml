<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>一刀切的弊端</title>
    <link href="/thinking/22_12_1/"/>
    <url>/thinking/22_12_1/</url>
    
    <content type="html"><![CDATA[<p>从11.27日的周日到12.1日的周四，发生了很多事情。下面的内容我希望大家从两面性来看待，一件事往往是要从两面来分析看待的，要坚持具体问题具体分析。</p><p>国内媒体的报道较少，群众获取消息的信息甚至只能从BBC等新闻渠道获取。</p><p>整件事情，我感觉更多的还是“一刀切”的工作方式导致的；</p><p>举个例子，地铁的安检主要是防范少数人的，但是导致整个群体都需要被检查是否携带危险物品，但是由于地铁实在太快，而安检的时间在人流量稳定时太短，群体中的每个人能够牺牲一点点的安检时间来换取更便捷快速的交通。这本身是个一刀切的过程，即让所有人为少数危险分子买单。在这个过程中，个人需要满足地铁安检+地铁通行时间&lt;&lt; 自身不用地铁交通时间，才是赚的。但一旦地铁安检时间过长，地铁通行时间过长，不满足了这个式子，亏了的心理就会出现。</p><p>而在疫情防控中，大部分学生，老师和地方上本就流动性不强的工作者却需要牺牲自我的活动空间来封控，牺牲自我的时间去避免疫情的扩大化。（1）核酸检测公司的上市，（2）核酸结果不正确，（3）不管怎么封控，境外输入还是存在，病例并未见的缓和，这三件事更加剧了人们心中的不安感。</p><p>而与此同时，12.10日即将出现的“一刀切”的互联网言论自由也将呈现在桌子上，更导致群众的不满。使得所有人需要为少数危险分子，极端分子买单。甚至可能以后不能谈论政治，不能发出一点谴责的声音。</p><p>保证“所有人的言论自由”为什么如此重要？言论不自由的前提得是政府是稳定运行下去的，控制言论的手段和工具不能落入恶劣分子手中。要确保发展的过程中不出现腐败分子，侵犯大众的权利的人存在。不然大众一旦想发出合理的声音，很可能会被恶劣分子掐断发声渠道，无法表达合理的诉求。举个很简单的例子，小区的物业问题，想倾诉不满或者向上汇报时，如果言论不自由，那将会导致信息传递极为困难，总不能人人都想一些“通假字”来避讳，还要保证消息接收方愿意接收消息。我也赞同是应该讲少部分的危险分子言论监控，但大众的声音不应该为危险分子买单。</p><p>好在经过这几天的发声，一些正向消息也在进入视眼。国人是极有勇气的，这让我想到了，“<em>中国人总是被他们</em>之中最<em>勇敢的人保护</em>得很好”。其中女性的力量甚至更胜男性。</p><p>11.27日，四川硬刚“核酸造假”第三方检测机构</p><p>11.28日，重庆市发布会说，核酸结果盲样考核不一致，实验室将被暂停检测资格。</p><p>11.29日，浙江宣传发文，“人民至上”而不是“防疫至上”</p><p>11.29日，“人民日报健康客户端”发表评论文章《核酸乱象不止，疫情永无宁日》，重点指出虚假的核酸报告会引发疫情扩散，让一轮又一轮的核酸检测持续数月，让区县甚至城市停摆，导致群众被静默，管控，影响工作生活。</p><p>以上是个人对目前发生事情一些粗浅见解，特此记录下来。文章想表达的重点是不能粗暴地“一刀切”。</p><p>这是我生长的地方，我希望能影响并改善它的不足。</p>]]></content>
    
    
    <categories>
      
      <category>think</category>
      
    </categories>
    
    
    <tags>
      
      <tag>think</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/java/doc-translation/java-lang-ref/"/>
    <url>/java/doc-translation/java-lang-ref/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-Doc-reference翻译"><a href="#Java-Doc-reference翻译" class="headerlink" title="[Java Doc]reference翻译"></a>[Java Doc]reference翻译</h1><p>oracle doc原文：<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/ref/package-summary.html#reachability">https://docs.oracle.com/javase/9/docs/api/java/lang/ref/package-summary.html#reachability</a></p><h1 id="Package-java-lang-ref"><a href="#Package-java-lang-ref" class="headerlink" title="Package java.lang.ref"></a>Package java.lang.ref</h1><p>since: 1.2</p><p>Provides reference-object classes, which support a limited degree of interaction with the garbage collector. A program may use a reference object to maintain a reference to some other object in such a way that the latter object may still be reclaimed by the collector. A program may also arrange to be notified some time after the collector has determined that the reachability of a given object has changed.</p><blockquote><p>提供引用对象类，它们支持同垃圾收集器有限程度的交互。程序可以使用一个引用对象来维护对某个其他对象的引用，利用这样的方式，后一个对象仍然可以被收集器回收。程序也可以安排在收集器确定给定对象的可达性已改变之后，于某个时候得到通知。</p><p>notify v 通知，唤醒</p></blockquote><h2 id="Package-Specification"><a href="#Package-Specification" class="headerlink" title="Package Specification"></a>Package Specification</h2><blockquote><p>包描述</p></blockquote><p>A <em>reference object</em> encapsulates a reference to some other object so that the reference itself may be examined and manipulated like any other object. Three types of reference objects are provided, each weaker than the last: <em>soft</em>, <em>weak</em>, and <em>phantom</em>. Each type corresponds to a different level of reachability, as defined below. Soft references are for implementing memory-sensitive caches, weak references are for implementing canonicalizing mappings that do not prevent their keys (or values) from being reclaimed, and phantom references are for scheduling post-mortem cleanup actions. Post-mortem cleanup actions can be registered and managed by a <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/ref/Cleaner.html"><code>Cleaner</code></a>.</p><blockquote><p>引用对象封装某个其他对象的引用，这使得引用对象本身可以像任何其他对象一样被检查和操作。提供三种引用对象，由从强到弱的顺序是：软引用(soft)，弱引用(*weak)*，虚引用( <em>phantom</em>)。每种类型都对应一个不同的可达度(GC中的可达度)，定义如下。软引用用于实现对内存敏感的缓存，弱引用用于实现不阻止键(或值)被回收的规范化映射，虚引用用于调度事后清理的操作。事后清理行为可以由<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/ref/Cleaner.html">Cleaner</a>对象注册和管理。</p><p>encapsulate v 简述，概括，压缩</p><p>canonicalizing v 规范化</p><p>examine 检查</p></blockquote><p>Each reference-object type is implemented by a subclass of the abstract base <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/ref/Reference.html"><code>Reference</code></a> class. An instance of one of these subclasses encapsulates a single reference to a particular object, called the <em>referent</em>. Every reference object provides methods for getting and clearing the reference. Aside from the clearing operation reference objects are otherwise immutable, so no <code>set</code> operation is provided. A program may further subclass these subclasses, adding whatever fields and methods are required for its purposes, or it may use these subclasses without change.</p><blockquote><p>每个引用对象都由抽象基类 Reference的子类实现。一个这些子类的实例封装了一个对于特定对象的单个引用，这个特定对象被叫做所指对象( <em>referent ,指称</em>)。每种引用对象都提供了获取和清理引用的方法。除了清理操作以外，引用对象是不可变的，所以不提供设置操作。程序可以扩展这些子类出新的子类，出于程序的目的来添加任何字段域(field)和方法(method)，或者不加任何改变来使用这些子类。</p><p>otherwise adv 否则，不然，反之</p><p>immutable adj 不可变</p></blockquote><h3 id="Notification"><a href="#Notification" class="headerlink" title="Notification"></a>Notification</h3><blockquote><p>通知，公示</p></blockquote><p>A program may request to be notified of changes in an object’s reachability by <em>registering</em> an appropriate reference object with a <em>reference queue</em> at the time the reference object is created. Some time after the garbage collector determines that the reachability of the referent has changed to the value corresponding to the type of the reference, it will clear the reference and add it to the associated queue. At this point, the reference is considered to be <em>enqueued</em>. The program may remove references from a queue either by polling or by blocking until a reference becomes available. Reference queues are implemented by the <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/ref/ReferenceQueue.html"><code>ReferenceQueue</code></a> class.</p><blockquote><p>程序可以通过在创建引用对象时，用引用队列注册一个合适的引用对象的方式，来请求通知对象的可达性的变化。在垃圾收集器决定所指对象 (referent) 的可达性变更到相应类型的值后的一段时间，垃圾收集器会清除引用并添加它到关联的队列中。此时，该引用被认为已入队了。程序通过轮询 (poll) 和阻塞 (blocking) 的方式，从队列中删除引用 (reference) ，直到引用 (reference) 变得的再次可达。引用队列由 ReferenceQueue 类实现。</p><p>appropriate adj 合适的，恰当的</p><p>corresponding to 相关的，对应的</p><p>associated 关联的</p><p>either .. or … 两者任一</p></blockquote><p>The relationship between a registered reference object and its queue is one-sided. That is, a queue does not keep track of the references that are registered with it. If a registered reference becomes unreachable itself, then it will never be enqueued. It is the responsibility of the program using reference objects to ensure that the objects remain reachable for as long as the program is interested in their referents.</p><blockquote><p>注册的引用对象和它的队列的关系是片面的。这是因为，队列并不跟踪其注册的引用们(references)。如果一个注册的引用自身变得不可达，之后它将永远不会入队。只要程序还关联引用所指对象(referent)，程序有责任，使用引用来确保对象的可访问性。</p><p>one-sided 片面的</p></blockquote><p>While some programs will choose to <strong>dedicate</strong> a thread to removing reference objects from one or more queues and processing them, this is by no means necessary. A <strong>tactic</strong> that often works well is to <strong>examine</strong> a reference queue in the course of performing some other <strong>fairly</strong>-frequent action. For example, a hashtable that uses weak references to implement weak keys could poll its reference queue each time the table is accessed. This is how the <a href="https://docs.oracle.com/javase/9/docs/api/java/util/WeakHashMap.html"><code>WeakHashMap</code></a> class works. Because the <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/ref/ReferenceQueue.html#poll--"><code>ReferenceQueue.poll</code></a> method simply checks an internal data structure, this check will add little overhead to the hashtable access methods.</p><blockquote><p>虽然一些程序会选择牺牲一个线程从一个或更多的队列删除引用对象和处理它们，但这绝不是必要的。一个通常工作很好的策略，是进行某种相当频繁的操作的时候，检查引用队列。例如，hashtable使用弱引用来实现弱键，当每次访问table的时候，可以轮询它的引用队列。这也是WeakHashMap类的工作原理。因为ReferenceQueue.poll 方法只是检查内部的数据结构，这项检查不会为hashtable访问方法添加额外的开销。</p><p>dedicate 奉献. dedicate&#x2F;devote&#x2F;consecrate sth to doing</p><p>by no means 绝不 this is by no means necessary</p><p>tactic n 策略</p><p>in the course of</p><p>fairly adv quite, considerably 相当地</p></blockquote><h3 id="Automatically-cleared-references"><a href="#Automatically-cleared-references" class="headerlink" title="Automatically-cleared references"></a>Automatically-cleared references</h3><blockquote><p>自动清理的引用们</p></blockquote><p>Soft and weak references are automatically cleared by the collector before being added to the queues with which they are registered, if any. Therefore soft and weak references need not be registered with a queue in order to be useful, while phantom references do. An object that is reachable via phantom references will remain so until all such references are cleared or themselves become unreachable.</p><p>软引用和弱引用在被添加到它们注册的队列中之前，会被垃圾收集器自动清理(如果有的话)。因此为了有效，软引用和弱引用不需要被注册到一个对列中，而虚引用需要添加到队列中。一个可以通过虚引用可达的对象将保持不变，直到所有引用被清除，或者对象自身变得不可达。</p><h3 id="Reachability"><a href="#Reachability" class="headerlink" title="Reachability"></a>Reachability</h3><blockquote><p>可达性</p></blockquote><p>Going from strongest to weakest, the different levels of reachability reflect the life cycle of an object. They are operationally defined as follows:</p><blockquote><p>从最强到最弱，不同可达性的等级反映了一个对象的生命周期。他们操作上被定义为下列：</p><p>operationally adj 操作上</p></blockquote><ul><li>An object is <em>strongly reachable</em> if it can be reached by some thread without traversing any reference objects. A newly-created object is strongly reachable by the thread that created it.</li><li>An object is <em>softly reachable</em> if it is not strongly reachable but can be reached by traversing a soft reference.</li><li>An object is <em>weakly reachable</em> if it is neither strongly nor softly reachable but can be reached by traversing a weak reference. When the weak references to a weakly-reachable object are cleared, the object becomes eligible for finalization.</li><li>An object is <em>phantom reachable</em> if it is neither strongly, softly, nor weakly reachable, it has been finalized, and some phantom reference refers to it.</li><li>Finally, an object is <em>unreachable</em>, and therefore eligible for reclamation, when it is not reachable in any of the above ways.</li></ul><blockquote><ul><li><p>(Strong)如果对象可以被某个线程不用通过任何引用对象访问，这个对象是强可达的。一个新建的对象对于创建它的线程来讲是强可达的。</p></li><li><p>(Soft)如果对象不是强可达，但是可以通过软引用(SoftReference)访问到，它是软可达的。</p></li><li><p>(Weak)如果对象既不是强可达，也不是软可达，但可以通过弱引用(WeakReference)访问到，它是弱可达的。当指向弱引用的弱引用被清除，对象就具备了结束(finalization)的条件。</p></li><li><p>(phantom) 如果对象既不是强可达，软可达，也不是弱可达，对象是虚可达(PhantomReference)。它已经被结束了(finalize)，并且某个虚引用指向它。</p></li><li><p>最终，当对象无法通过上述任何一种方式到达时，对象是不可达状态(unreachable)，因此具备了进行回收的资格。</p></li></ul><p>reclamation n 回收</p></blockquote><h3 id="Interface-Summary"><a href="#Interface-Summary" class="headerlink" title="Interface Summary"></a>Interface Summary</h3><blockquote><p>接口摘要</p></blockquote><table><thead><tr><th>Interface</th><th>Description</th></tr></thead><tbody><tr><td>Cleaner.Cleanable</td><td><code>Cleanable</code> represents an object and a cleaning action registered in a <code>Cleaner</code>.</td></tr><tr><td></td><td><code>Cleanable</code> 表示在 <code>Cleaner</code>上注册的对象和清理工作。注：Cleanable接口只有一个clean()方法。</td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>并发编程 - 解析 ThreadPoolExecutor</title>
    <link href="/java-concurrency-programming/thread-executor/"/>
    <url>/java-concurrency-programming/thread-executor/</url>
    
    <content type="html"><![CDATA[<h2 id="解析ThreadPoolExecutor"><a href="#解析ThreadPoolExecutor" class="headerlink" title="解析ThreadPoolExecutor"></a>解析ThreadPoolExecutor</h2><p>本文通过源码解析 ThreadPoolExecutor，<br>来了解实践中如何设置线程池参数，分析美团线程池实践中如何动态设置线程池参数。</p><h3 id="ThreadPoolExecutor-常用的方法"><a href="#ThreadPoolExecutor-常用的方法" class="headerlink" title="ThreadPoolExecutor 常用的方法"></a>ThreadPoolExecutor 常用的方法</h3><p>Executor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span><br></code></pre></td></tr></table></figure><hr><p>ExecutorService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span>;<br>List&lt;Runnable&gt; <span class="hljs-title function_">shutdownNow</span><span class="hljs-params">()</span>;<br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isShutdown</span><span class="hljs-params">()</span>;<br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isTerminated</span><span class="hljs-params">()</span>;<br><span class="hljs-type">boolean</span> <span class="hljs-title function_">awaitTermination</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span>;<br>Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">()</span>;<br>List&lt;Future&lt;T&gt;&gt; <span class="hljs-title function_">invokeAll</span><span class="hljs-params">()</span>;<br>T <span class="hljs-title function_">invokeAny</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><hr><p>ThreadPoolExecutor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">getPoolSize #线程池的线程数<br>getActiveCount # 活跃线程数<br>getCompletedTaskCount #完成的任务数<br>getQueue().size()  #队列中的任务数<br></code></pre></td></tr></table></figure><h3 id="ThreadPoolExecutor-构造函数"><a href="#ThreadPoolExecutor-构造函数" class="headerlink" title="ThreadPoolExecutor 构造函数"></a>ThreadPoolExecutor 构造函数</h3><p><code>Executors</code>的固定线程池，缓存线程池，单线程池也是通过构造ThreadPoolExecutor对象的方式构造出来的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用给定的初始参数创建一个新的ThreadPoolExecutor。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize, //线程池的核心线程数量</span><br><span class="hljs-params">                              <span class="hljs-type">int</span> maximumPoolSize,//线程池的最大线程数</span><br><span class="hljs-params">                              <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                              //当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span><br><span class="hljs-params">                              TimeUnit unit,//时间单位</span><br><span class="hljs-params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">                              //任务队列，用来储存等待执行任务的队列</span><br><span class="hljs-params">                              ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可</span><br><span class="hljs-params">                              RejectedExecutionHandler handler</span><br><span class="hljs-params">                              //拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span><br><span class="hljs-params">                               )</span> &#123;<br>        <span class="hljs-keyword">if</span> (corePoolSize &lt; <span class="hljs-number">0</span> ||<br>            maximumPoolSize &lt;= <span class="hljs-number">0</span> ||<br>            maximumPoolSize &lt; corePoolSize ||<br>            keepAliveTime &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>        <span class="hljs-keyword">if</span> (workQueue == <span class="hljs-literal">null</span> || threadFactory == <span class="hljs-literal">null</span> || handler == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>        <span class="hljs-built_in">this</span>.corePoolSize = corePoolSize;<br>        <span class="hljs-built_in">this</span>.maximumPoolSize = maximumPoolSize;<br>        <span class="hljs-built_in">this</span>.workQueue = workQueue;<br>        <span class="hljs-built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);<br>        <span class="hljs-built_in">this</span>.threadFactory = threadFactory;<br>        <span class="hljs-built_in">this</span>.handler = handler;<br>    &#125;<br></code></pre></td></tr></table></figure><p>使用阿里巴巴推荐的创建线程池的方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CORE_POOL_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_POOL_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">QUEUE_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Long</span> <span class="hljs-variable">KEEP_ALIVE_TIME</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;    <br><br><span class="hljs-comment">//通过ThreadPoolExecutor构造函数自定义参数创建</span><br><span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>  CORE_POOL_SIZE,<br>  MAX_POOL_SIZE,<br>  KEEP_ALIVE_TIME,<br>  TimeUnit.SECONDS,<br>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(QUEUE_CAPACITY),<br>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());<br><br></code></pre></td></tr></table></figure><p><code>ThreadPoolExecutor</code> 3 个最重要的参数：</p><ul><li><code>corePoolSize</code> : 核心线程数线程数定义了最小可以同时运行的线程数量。</li><li><code>maximumPoolSize</code> :  最大池数量，注意：实际最大值在内部由 CAPACITY 限制</li><li><code>workQueue</code>: 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li></ul><p><code>ThreadPoolExecutor</code>其他常见参数:</p><ol><li><code>keepAliveTime</code>:当线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁；</li><li><code>unit</code> : <code>keepAliveTime</code> 参数的时间单位。</li><li><code>threadFactory</code> :executor 创建新线程的时候会用到。</li><li><code>handler</code> :饱和策略。关于饱和策略下面单独介绍一下。</li></ol><p><code>ThreadPoolExecutor</code> 饱和策略定义:</p><p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，<code>ThreadPoolTaskExecutor</code> 定义一些策略:</p><ul><li><code>ThreadPoolExecutor.AbortPolicy</code>：抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。默认是该策略</li><li><code>ThreadPoolExecutor.CallerRunsPolicy</code>：调用执行自己的线程运行任务。您不会任务请求。但是这种策略会降低对于新任务提交速度，影响程序的整体性能。另外，这个策略喜欢增加队列容量。对于可伸缩的应用程序，如果您的应用程序可以承受此延迟并且你不能任务丢弃任何一个任务请求的话，你可以选择这个策略。</li><li><code>ThreadPoolExecutor.DiscardPolicy</code>：不处理新任务，直接丢弃掉。</li><li><code>ThreadPoolExecutor.DiscardOldestPolicy</code>： 此策略将丢弃最早的未处理的任务请求。</li></ul><h3 id="设置线程池名称"><a href="#设置线程池名称" class="headerlink" title="设置线程池名称"></a>设置线程池名称</h3><p>为了便于定位问题，线程池在实践中应当命名。</p><ol><li>利用 <code>ThreadFactoryBuilder</code></li></ol><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ThreadFactory</span> <span class="hljs-variable">threadFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadFactoryBuilder</span>()<br>                        .setNameFormat(threadNamePrefix + <span class="hljs-string">&quot;-%d&quot;</span>)<br>                        .setDaemon(<span class="hljs-literal">true</span>).build();<br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(corePoolSize, maximumPoolSize, keepAliveTime, TimeUnit.MINUTES, workQueue, threadFactory)<br></code></pre></td></tr></table></figure><ol start="2"><li>自己实现 <code>ThreadFactory</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><span class="hljs-keyword">import</span> java.util.concurrent.ThreadFactory;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 线程工厂，它设置线程名称，有利于我们定位问题。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NamingThreadFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ThreadFactory</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">threadNum</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ThreadFactory delegate;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建一个带名字的线程池生产工厂</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NamingThreadFactory</span><span class="hljs-params">(ThreadFactory delegate, String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.delegate = delegate;<br>        <span class="hljs-built_in">this</span>.name = name; <span class="hljs-comment">// TODO consider uniquifying this</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span> <br>    <span class="hljs-keyword">public</span> Thread <span class="hljs-title function_">newThread</span><span class="hljs-params">(Runnable r)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> delegate.newThread(r);<br>        t.setName(name + <span class="hljs-string">&quot; [#&quot;</span> + threadNum.incrementAndGet() + <span class="hljs-string">&quot;]&quot;</span>);<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h3><p>源码中runState和workerCount维护是放在一起的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">ctl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="hljs-number">0</span>));<br></code></pre></td></tr></table></figure><p>ctl的高3位保存runState，低29位保存workerCount</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">runStateOf</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>     &#123; <span class="hljs-keyword">return</span> c &amp; ~CAPACITY; &#125; <span class="hljs-comment">//计算当前运行状态</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">workerCountOf</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>  &#123; <span class="hljs-keyword">return</span> c &amp; CAPACITY; &#125;  <span class="hljs-comment">//计算当前线程数量</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ctlOf</span><span class="hljs-params">(<span class="hljs-type">int</span> rs, <span class="hljs-type">int</span> wc)</span> &#123; <span class="hljs-keyword">return</span> rs | wc; &#125;   <span class="hljs-comment">//通过状态和线程数生成ctl</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>运行状态</th><th>状态描述</th></tr></thead><tbody><tr><td>running</td><td>能接受新提交的任务，并能处理阻塞队列中的任务。</td></tr><tr><td>Shutdown</td><td>关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务。</td></tr><tr><td>Stop</td><td>不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。</td></tr><tr><td>Tidying</td><td>所有任务都终止了，workerCount为0</td></tr><tr><td>Terminated</td><td>在terminated() 方法执行完成后进入该状态</td></tr></tbody></table><p><img src="/java-concurrency-programming/thread-executor/lifecyc-thread-pool.png" alt="lifecyc-thread-pool"></p><h3 id="任务调度过程"><a href="#任务调度过程" class="headerlink" title="任务调度过程"></a>任务调度过程</h3><ol><li>首先检测线程池运行状态，如果不是RUNNING，则直接拒绝，线程池要保证在RUNNING的状态下执行任务。</li><li>如果workerCount &lt; corePoolSize，则创建并启动一个线程来执行新提交的任务。</li><li>如果workerCount &gt;&#x3D; corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中。</li><li>如果workerCount &gt;&#x3D; corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务。</li><li>如果workerCount &gt;&#x3D; maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。</li></ol><p>阻塞队列</p><p><img src="/java-concurrency-programming/thread-executor/thread-block-queue.png" alt="thread-block-queue.png"></p><h3 id="线程池核心问题：设置参数"><a href="#线程池核心问题：设置参数" class="headerlink" title="线程池核心问题：设置参数"></a>线程池核心问题：设置参数</h3><p>ThreadPoolExecutor主要有7个参数</p><ol><li><p><strong>corePoolSize</strong>：the number of threads to keep in the pool, even if they are idle, unless {@code allowCoreThreadTimeOut} is set</p><p>（核心线程数大小：不管它们创建以后是不是空闲的。线程池需要保持 corePoolSize 数量的线程，除非设置了 allowCoreThreadTimeOut。）</p></li><li><p><strong>maximumPoolSize</strong>：the maximum number of threads to allow in the pool。</p><p>（最大线程数：线程池中最多允许创建 maximumPoolSize 个线程。）</p></li><li><p><strong>keepAliveTime</strong>：when the number of threads is greater than the core, this is the maximum time that excess idle threads will wait for new tasks before terminating。</p><p>（存活时间：如果经过 keepAliveTime 时间后，超过核心线程数的线程还没有接受到新的任务，那就回收。）</p></li><li><p><strong>unit：</strong>the time unit for the {@code keepAliveTime} argument</p><p>（keepAliveTime 的时间单位。）</p></li><li><p><strong>workQueue</strong>：the queue to use for holding tasks before they are executed.  This queue will hold only the {@code Runnable} tasks submitted by the {@code execute} method。</p><p>（存放待执行任务的队列：当提交的任务数超过核心线程数大小后，再提交的任务就存放在这里。它仅仅用来存放被 execute 方法提交的 Runnable 任务。所以这里就不要翻译为工作队列了，好吗？不要自己给自己挖坑。）</p></li><li><p><strong>threadFactory</strong>：the factory to use when the executor creates a new thread。</p><p>（线程工程：用来创建线程工厂。比如这里面可以自定义线程名称，当进行虚拟机栈分析时，看着名字就知道这个线程是哪里来的，不会懵逼。）</p></li><li><p><strong>handler</strong> ：the handler to use when execution is blocked because the thread bounds and queue capacities are reached。</p><p>（拒绝策略：当队列里面放满了任务、最大线程数的线程都在工作时，这时继续提交的任务线程池就处理不了，应该执行怎么样的拒绝策略。）</p></li></ol><p>其中最重要的是3个参数：corePoolSize，maximumPoolSize，workQueue</p><h4 id="corePoolSize"><a href="#corePoolSize" class="headerlink" title="corePoolSize"></a>corePoolSize</h4><p>有一个简单并且适用面比较广的公式：</p><ul><li><p><strong>CPU 密集型任务(N+1)：</strong> 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。(《Java并发编程实战》中的解释)</p></li><li><p><strong>I&#x2F;O 密集型任务(2N)：</strong> 这种任务应用起来，系统会用大部分的时间来处理 I&#x2F;O 交互，而线程在处理 I&#x2F;O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I&#x2F;O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</p></li></ul><p>获取处理器逻辑核心数量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">N_CPUS</span> <span class="hljs-operator">=</span> Runtime.getRuntime().availableProcessors();<br></code></pre></td></tr></table></figure><p><strong>如何判断是 CPU 密集任务还是 IO 密集任务？</strong></p><p>CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。</p><p>但凡涉及到网络读取，文件读取这类都是 IO 密集型，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。</p><p>美团在实践中提出了将线程池参数动态化的方式</p><h4 id="线程池预热"><a href="#线程池预热" class="headerlink" title="线程池预热"></a>线程池预热</h4><p>线程池被创建后如果没有任务过来，里面是不会有线程的。如果需要预热的话可以调用下面的两个方法</p><p>第一个是全启动</p><p>第二个是仅启动一个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Starts all core threads, causing them to idly wait for work. This</span><br><span class="hljs-comment"> * overrides the default policy of starting core threads only when</span><br><span class="hljs-comment"> * new tasks are executed.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the number of threads started</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">prestartAllCoreThreads</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>))<br>        ++n;<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Starts a core thread, causing it to idly wait for work. This</span><br><span class="hljs-comment"> * overrides the default policy of starting core threads only when</span><br><span class="hljs-comment"> * new tasks are executed. This method will return &#123;<span class="hljs-doctag">@code</span> false&#125;</span><br><span class="hljs-comment"> * if all core threads have already been started.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@code</span> true&#125; if a thread was started</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">prestartCoreThread</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> workerCountOf(ctl.get()) &lt; corePoolSize &amp;&amp;<br>        addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="核心线程数会被回收吗"><a href="#核心线程数会被回收吗" class="headerlink" title="核心线程数会被回收吗"></a>核心线程数会被回收吗</h4><p>核心线程数默认不会被回收。</p><p>线程池中线程的销毁依赖JVM自动的回收，线程池做的工作是根据当前线程池的状态维护一定数量的线程引用，防止这部分线程被JVM回收，当线程池决定哪些线程需要回收时，只需要将其引用消除即可。Worker被创建出来后，就会不断地进行轮询，然后获取任务去执行，核心线程可以无限等待获取任务，非核心线程要限时获取任务。当Worker无法获取到任务，也就是获取的任务为空时，循环会结束，<strong>Worker会主动消除自身在线程池内的引用</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-keyword">while</span> (task != <span class="hljs-literal">null</span> || (task = getTask()) != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">//执行任务</span><br>  &#125;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>  processWorkerExit(w, completedAbruptly);<span class="hljs-comment">//获取不到任务时，主动回收自己</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/java-concurrency-programming/thread-executor/thread-collect.png" alt="thread-collect.png"></p><p>如需回收核心线程数，需要调用下面的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Sets the policy governing whether core threads may time out and</span><br><span class="hljs-comment">     * terminate if no tasks arrive within the keep-alive time, being</span><br><span class="hljs-comment">     * replaced if needed when new tasks arrive. When false, core</span><br><span class="hljs-comment">     * threads are never terminated due to lack of incoming</span><br><span class="hljs-comment">     * tasks. When true, the same keep-alive policy applying to</span><br><span class="hljs-comment">     * non-core threads applies also to core threads. To avoid</span><br><span class="hljs-comment">     * continual thread replacement, the keep-alive time must be</span><br><span class="hljs-comment">     * greater than zero when setting &#123;<span class="hljs-doctag">@code</span> true&#125;. This method</span><br><span class="hljs-comment">     * should in general be called before the pool is actively used.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value &#123;<span class="hljs-doctag">@code</span> true&#125; if should time out, else &#123;<span class="hljs-doctag">@code</span> false&#125;</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IllegalArgumentException if value is &#123;<span class="hljs-doctag">@code</span> true&#125;</span><br><span class="hljs-comment">     *         and the current keep-alive time is not greater than zero</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span> 1.6</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">allowCoreThreadTimeOut</span><span class="hljs-params">(<span class="hljs-type">boolean</span> value)</span> &#123;<br>        <span class="hljs-keyword">if</span> (value &amp;&amp; keepAliveTime &lt;= <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Core threads must have nonzero keep alive times&quot;</span>);<br>        <span class="hljs-keyword">if</span> (value != allowCoreThreadTimeOut) &#123;<br>            allowCoreThreadTimeOut = value;<br>            <span class="hljs-keyword">if</span> (value)<br>                interruptIdleWorkers();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">美团线程池实践</a></p>]]></content>
    
    
    <categories>
      
      <category>concurrency</category>
      
    </categories>
    
    
    <tags>
      
      <tag>concurrency</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发编程 - 线程池 Thread Pool</title>
    <link href="/java-concurrency-programming/thread-pool/"/>
    <url>/java-concurrency-programming/thread-pool/</url>
    
    <content type="html"><![CDATA[<p>本文介绍了Java中的几种线程池，及Executors构造线程池的用法。</p><h2 id="Java-线程池-Thread-Pool"><a href="#Java-线程池-Thread-Pool" class="headerlink" title="Java 线程池 Thread Pool"></a>Java 线程池 Thread Pool</h2><p>构建新线程的开销较大。如果程序中需要创建大量很短生命期的线程，应该使用<strong>线程池</strong>，而不是将每个任务映射到一个单独线程。</p><p>线程池中包含很多准备运行的线程，每为线程池提供一个Runnable实例，就会有一个池中的线程调用run方法。当run方法退出时，这个线程不会死亡，而是留在池中准备为下一个请求 (Runnable实例) 提供服务。</p><h3 id="执行器-Executors"><a href="#执行器-Executors" class="headerlink" title="执行器 Executors"></a>执行器 Executors</h3><p>执行器有许多静态工厂方法，用来构造线程池。<br>静态工厂方法返回类型为 <code>ExecutorService</code></p><center> 表格 Executors工厂方法 </center><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>newCachedThreadPool</td><td>必要时创建新线程；空闲线程会保留60 s</td></tr><tr><td>newFixedThreadPool</td><td>池中包含固定数目的线程；空闲线程会一直保留</td></tr><tr><td>newWorkStealingPool</td><td>一种适合“fork-join”任务的线程池，其中复杂的任务会分解为更简单的任务，空闲线程会“密取”较简单的任务</td></tr><tr><td>newSingleThreadExecutor</td><td>只有一个线程的“池”，会顺序地执行所提交的任务</td></tr><tr><td>newScheduledThreadPool</td><td>用于调度执行的固定线程池</td></tr><tr><td>newSingleThreadScheduledExecutor</td><td>用于调度执行的单线程池</td></tr></tbody></table><h4 id="缓存线程池-newCachedThreadPool"><a href="#缓存线程池-newCachedThreadPool" class="headerlink" title="缓存线程池 newCachedThreadPool"></a>缓存线程池 newCachedThreadPool</h4><p>构造一个线程池，会立即执行各个任务。如果有空闲线程可用，就使用现有空闲线程执行任务；如果没有可用的空闲线程，则创建一个新线程。</p><h4 id="固定线程池-newFixedThreadPool"><a href="#固定线程池-newFixedThreadPool" class="headerlink" title="固定线程池 newFixedThreadPool"></a>固定线程池 newFixedThreadPool</h4><p>构造一个固定大小的线程池。如果提交的任务数多于空闲线程数，就把未得到服务的任务放到队列中。当其他任务完成以后再运行这些排队的任务。</p><h4 id="单线程池-newSingleThreadExecutor"><a href="#单线程池-newSingleThreadExecutor" class="headerlink" title="单线程池 newSingleThreadExecutor"></a>单线程池 newSingleThreadExecutor</h4><p>是一个退化了的大小为1的线程池：由一个线程顺序地执行所提交的任务（顺序执行）。</p><p>参考上面的 FixedThreadPool</p><h4 id="使用线程池的小结"><a href="#使用线程池的小结" class="headerlink" title="使用线程池的小结"></a>使用线程池的小结</h4><p>如果线程生存时间很短，或者大量时间都在阻塞，业务是轻量负载的，可以使用<strong>缓存线程池</strong>。</p><p><strong>为了获得最优的运行速度</strong>，业务是高负载的，可以令并发线程数等于处理内核数(查看CPU内核数方法见下文)。在这种情况下，就应该使用<strong>固定线程池</strong>，即并发线程总数有一个上限。</p><p><strong>单线程池</strong>对于<strong>性能分析</strong>很有帮助。如临时使用一个单线程池替换其他线程池，就能测量不适用并发的情况下应用的运行速度会慢多少。</p><p>实际使用的时候推荐自己创建<code>ThreadPoolExecutor</code> (避免OOM)</p><blockquote><p>Executors 返回线程池对象的弊端如下：</p><ul><li><code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code>： 允许请求的队列长度为 &gt; <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li><li><code>CachedThreadPool </code>和<code> ScheduledThreadPool</code> ： 允许创建的线程数量为 &gt; <code>Integer.MAX_VALUE</code> ，可能会创建大量线程，从而导致 OOM。</li></ul></blockquote><p>综合来讲，因为队列上限和创建线程上限，导致OOM发生。</p><p>除了避免 OOM 的原因之外，不推荐使用 <code>Executors </code>提供的两种快捷的线程池的原因还有：</p><ol><li>实际使用中需要根据自己机器的性能、业务场景来手动配置线程池的参数比如核心线程数、使用的任务队列、饱和策略等等。</li><li>我们应该显示地给我们的线程池命名，这样有助于我们定位问题。</li></ol><h5 id="如何查看CPU内核数量"><a href="#如何查看CPU内核数量" class="headerlink" title="如何查看CPU内核数量"></a>如何查看CPU内核数量</h5><p>Linux: <code>cat /proc/cpuinfo| grep &quot;cpu cores&quot;| uni</code></p><p>Mac: 查看物理内核 <code>sysctl hw.physicalcpu</code></p><p>逻辑内核 <code>sysctl hw.logicalcpu</code></p><hr><h3 id="ExecutorService分析"><a href="#ExecutorService分析" class="headerlink" title="ExecutorService分析"></a>ExecutorService分析</h3><p>上文中的几种线程池都属于<code>ThreadPoolExecutor</code>类，实现了<code>ExecutorService</code>的接口。</p><center>图 ExecutorService 继承关系</center><img src="executorService.png" alt="executorService" style="zoom: 67%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span>;<br>Future&lt;?&gt; submit(Runnable task);<br>Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Runnable task, T result)</span>;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span>;<br>List&lt;Runnable&gt; <span class="hljs-title function_">shutdownNow</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><p>调用submit时，会得到<strong>Future</strong>对象，可用来得到结果(get)或者取消任务(cancel)。</p><p>第二个submit返回的<strong>Future</strong>对象可以来调用isDone, cancel, isCancelled。但是get方法在完成的时候只是简单返回null。</p><p>第三个submit也生成一个<strong>Future</strong>，它的get方法在完成的时候返回指定的result对象。</p><p>shutdown 用于关闭线程池，被关闭的线程池不再接受新任务，当所有任务完成时，线程池中的线程死亡。</p><p>shutdownNow 会取消所有尚未开始的任务。</p><hr><h3 id="fork-join框架"><a href="#fork-join框架" class="headerlink" title="fork-join框架"></a>fork-join框架</h3><p>有一些应用可能对处理器内核分别使用一个线程，以完成计算密集型任务，如图像或视频处理的应用。Java 7 中新引入了fork-join框架，专门用来支持这一类应用。</p><p>假设有一个处理任务，它可以很自然地分解为子任务，如下所示</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">if</span> problemSize &lt; threshold<br>solve problem directly<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">break</span> problem <span class="hljs-keyword">into</span> subproblems<br>recursively solve <span class="hljs-keyword">each</span> subproblem<br>conbine the results<br>&#125;<br></code></pre></td></tr></table></figure><p>为了完成这种递归计算，需要提供扩展<code>RecursiveTask&lt;T&gt;</code>的类或者提供扩展<code>RecursiveAction&lt;T&gt;</code>的类。再覆盖compute方法来生成并调用子任务。</p><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecursiveTask</span>&lt;Integer&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">THRESHOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> to, from;<br>    <span class="hljs-keyword">private</span> DoublePredicate filter;<br>    <span class="hljs-type">int</span>[] values;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Counter</span><span class="hljs-params">(<span class="hljs-type">int</span>[] numbers, <span class="hljs-type">int</span> from, <span class="hljs-type">int</span> to, DoublePredicate filter)</span> &#123;<br>        <span class="hljs-built_in">this</span>.values = numbers;<br>        <span class="hljs-built_in">this</span>.from = from;<br>        <span class="hljs-built_in">this</span>.to = to;<br>        <span class="hljs-built_in">this</span>.filter = filter;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (to - from &lt; THRESHOLD) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> from; i &lt; to; i++) &#123;<br>                <span class="hljs-keyword">if</span> (filter.test(values[i])) count++;<br>            &#125;<br>            <span class="hljs-keyword">return</span> count;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (to + from) / <span class="hljs-number">2</span>;<br>            <span class="hljs-type">Counter</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Counter</span>(values, from, mid, filter);<br>            <span class="hljs-type">Counter</span> <span class="hljs-variable">second</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Counter</span>(values, mid, to, filter);<br>            invokeAll(first, second);<br>            <span class="hljs-keyword">return</span> first.join() + second.join();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在后台，fork-join采用了一种有效的智能方法来平衡可用线程的工作负载，这种方法称为工作密取(work-stealing)。一个工作线程将子任务压入双端队列的队头(只有一个线程可以访问队头，故可以不加锁)，另一个工作线程空闲时，它会从双端队列的队尾“密取”一个任务。</p><blockquote><p>⚠️警告: fork-join池是针对非阻塞工作负载优化的。如果向一个fork-join池增加很多阻塞任务，会使其无法有效工作。</p></blockquote><h3 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h3><p><a href="http://fuheihei.github.io/java-concurrency-programming/thread-executor">解析ThreadPoolExecutor</a></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg3NjU3NTkwMQ==&mid=2247505103&idx=1&sn=a041dbec689cec4f1bbc99220baa7219&source=41#wechat_redirect">如何设置线程池参数？美团给出了一个让面试官虎躯一震的回答  作者: why技术</a></p>]]></content>
    
    
    <categories>
      
      <category>concurrency</category>
      
    </categories>
    
    
    <tags>
      
      <tag>concurrency</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何写博客</title>
    <link href="/tools/how-to-write-blog/"/>
    <url>/tools/how-to-write-blog/</url>
    
    <content type="html"><![CDATA[<p>我建立博客的初心是记录技术，并将自己在编程中学到的知识，写成规范的文档形式。</p><p>将自己学会的技术写成文档的过程，类似于嚼饭给别人吃，如果自己的积累不到位，饭就嚼得不好。</p><p>需要作者本身尽力做到内容对自己对他人都是有帮助的。</p><h3 id="1-文档工具"><a href="#1-文档工具" class="headerlink" title="1. 文档工具"></a>1. 文档工具</h3><p>博客文章格式还是markdown为主</p><h3 id="2-markdown写作规范"><a href="#2-markdown写作规范" class="headerlink" title="2. markdown写作规范"></a>2. markdown写作规范</h3><p>写作规范详细参考github上的 <a href="https://github.com/fex-team/styleguide/blob/master/markdown.md">Markdown 编写规范-中文</a></p><h3 id="3-字体"><a href="#3-字体" class="headerlink" title="3. 字体"></a>3. 字体</h3><p>编写博客过程中需要用到不同的字体颜色，来标识不同重要程度的内容。</p><p>正常字体是默认的黑色，下列提供可供参考配色的颜色设计网站</p><p><a href="https://flatuicolors.com/palette/defo">1 - FlatUI 配色</a></p><p><a href="https://ant.design/docs/spec/colors-cn#%E5%9C%A8%E4%BB%A3%E7%A0%81%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%89%B2%E6%9D%BF">2 - Ant Design 配色</a></p><p><span style="color:#fe6673">红色 #fe6673 </span> 重要的内容</p><p><span style="color:#3498db">蓝色 #3498db</span> 新名词首次出现</p><p><span style="color:#f1c40f">黄色 #f1c40f</span> warning警告相关的颜色</p><p><span style="color:#27ae60">绿色 #27ae60</span> 论证过程，或者过程性质的代码</p><p>如下所示，在md中嵌入html标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:...&quot;</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> <span class="hljs-comment">&lt;!--用标签包裹需要上色的文字--&gt;</span><br></code></pre></td></tr></table></figure><h3 id="4-代码样式"><a href="#4-代码样式" class="headerlink" title="4. 代码样式"></a>4. 代码样式</h3><p>博客中的代码部分格式以markdown样式为主，分为大的代码块（带行号）和普通代码行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">hello world <span class="hljs-comment">//代码块</span><br></code></pre></td></tr></table></figure><p><code>hello world</code> 普通代码行</p><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><p>每天进步一点点，保持笔记的清晰有条理。</p>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>个人博客搭建</title>
    <link href="/tools/how-to-build-my-blog/"/>
    <url>/tools/how-to-build-my-blog/</url>
    
    <content type="html"><![CDATA[<p>搭建个人博客 hexo+kaze+gitalk。</p><p>我们经常会看到github有人有<code>&lt;username&gt;.github.io</code>形式的个人博客网页，他们是怎么做到的呢？</p><p>仔细观察，不少人的博客底部还会出现 “powered by hexo” 或者 “由hexo强力驱动” 的字样</p><p>通过下文，你也可以搭建一个自己的github pages博客</p><h2 id="1-Github-Pages"><a href="#1-Github-Pages" class="headerlink" title="1.Github Pages"></a>1.Github Pages</h2><p>没错，浏览器中url为<code>&lt;username&gt;.github.io</code>形式的博客是github提供的一种博客功能，这个功能叫做github pages。<br>当用户在github上新建了<code>&lt;username&gt;.github.io</code>的public的仓库(<code>&lt;username&gt;</code>和自己的github用户名一致)，就可以为自己生成对应的github pages。并且其他访客可以通过这个url访问你的博客。</p><h2 id="2-hexo项目构建"><a href="#2-hexo项目构建" class="headerlink" title="2. hexo项目构建"></a>2. hexo项目构建</h2><h3 id="2-1用-hexo初始化项目"><a href="#2-1用-hexo初始化项目" class="headerlink" title="2.1用 hexo初始化项目"></a>2.1用 hexo初始化项目</h3><p>第一步，安装hexo</p><p>通过hexo-cli的方式，构建博客项目会更容易。</p><p>环境：需要git，node环境(&gt;&#x3D;12.0.0, 推荐nvm安装node)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-cli -g<br></code></pre></td></tr></table></figure><p>详细安装配置可以看<a href="https://hexo.io/zh-cn/docs/">hexo官网文档 </a><br>(简便安装上面一行指令就够了)</p><p>第二步，接着hexo在本地构建项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init &lt;project_url&gt; <span class="hljs-comment">#初始化项目</span><br><span class="hljs-built_in">cd</span> &lt;project_url&gt; <span class="hljs-comment">#进入项目路径</span><br></code></pre></td></tr></table></figure><p>常用的hexo指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo g <span class="hljs-comment">#即 hexo generate，生成静态文件</span><br>hexo s <span class="hljs-comment">#即 hexo server，本地运行服务器</span><br>hexo d <span class="hljs-comment">#即 hexo deploy，部署服务器，常用指令 hexo clean &amp;&amp; hexo d</span><br></code></pre></td></tr></table></figure><h3 id="2-2-新建github-pages-仓库"><a href="#2-2-新建github-pages-仓库" class="headerlink" title="2.2 新建github pages 仓库"></a>2.2 新建github pages 仓库</h3><p>新建一个github项目，项目名为&#96;&#96;{username}<code>.github.io</code>，项目是public的而非private的。</p><p>修改本地hexo项目根目录下的 _config.yml文件，添加 deploy 相关的属性。</p><p>需要指定发布项目的repo，这里因为我们用的是github pages，github pages通常是<code> &#123;username&#125;</code>.github.io&#96;形式的public仓库。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Deployment</span><br><span class="hljs-comment">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">git@github.com:fuheihei/fuheihei.github.io.git</span> <span class="hljs-comment"># 指定为你的github pages的git地址</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">main</span> <span class="hljs-comment">#对应的git分支</span><br></code></pre></td></tr></table></figure><h2 id="3-博客主题的选取"><a href="#3-博客主题的选取" class="headerlink" title="3.博客主题的选取"></a>3.博客主题的选取</h2><p>hexo构建的博客项目可以选取很多开源的hexo主题，类似于qq空间的皮肤，我们通过修改根目录下<code>_config.yml</code>中的属性<code>theme: </code>就能指定对应的皮肤。</p><p>例如</p><p>想要选择的主题是<a href="https://github.com/Ben02/hexo-theme-Anatole">anatole</a></p><p>将主题项目 <code>git clone</code> 到项目中的themes文件夹下，修改项目根目录下的<code>_config.yml</code>中的属性</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">theme: anatole  <span class="hljs-comment">#将theme指定为anatole</span><br><span class="hljs-comment"># Extensions</span><br><span class="hljs-comment">## Plugins: https://hexo.io/plugins/</span><br><span class="hljs-comment">## Themes: https://hexo.io/themes/</span><br></code></pre></td></tr></table></figure><p>需要注意的是，如果指定为anatole，那么项目必须得有theme&#x2F;anatole文件夹。</p><p>其他丰富的hexo主题请查阅: <a href="https://hexo.io/themes/">https://hexo.io/themes/</a></p><h2 id="4-写文章"><a href="#4-写文章" class="headerlink" title="4.写文章"></a>4.写文章</h2><h3 id="4-1-新建文章"><a href="#4-1-新建文章" class="headerlink" title="4.1 新建文章"></a>4.1 新建文章</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new [layout] &lt;title文章名&gt;<br></code></pre></td></tr></table></figure><p>例如 <code>hexo new post how-to-build-my-blog</code></p><p><code>[layout]</code>可以是 post、page 和 draft，其位置和source&#x2F;_post，source&#x2F;page，source&#x2F;_draft是相关联的。</p><h3 id="4-2-发布文章"><a href="#4-2-发布文章" class="headerlink" title="4.2 发布文章"></a>4.2 发布文章</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo g <span class="hljs-comment">#即 hexo generate，生成静态文件</span><br>hexo s <span class="hljs-comment">#即 hexo server，本地运行服务器</span><br>hexo d <span class="hljs-comment">#即 hexo deploy，部署服务器，也可以用指令 hexo clean &amp;&amp; hexo d</span><br></code></pre></td></tr></table></figure><p>hexo d可以将本地的hexo 项目转换成github pages需要的项目发布在你的github repo中，在浏览器输入 <code>&lt;username&gt;.github.io</code> 就能看到和本地一样的hexo博客了。</p><h2 id="5-评论系统"><a href="#5-评论系统" class="headerlink" title="5.评论系统"></a>5.评论系统</h2><p>完善的博客还应该提供访问用户讨论的机会。</p><img src="comments.png" alt="gitalk的demo图" width="80%" height="80%"><p></p><p style="text-align:center">gitalk的demo图</p><p>评论系统有很多，出于免费和效率考虑，此处使用gitalk</p><p>gitalk是github提供的评论系统，免费；同时gitalk的用户评论文章的内容可以在repo生成对应的issues，可以起到邮件通知的效果，保证及时回复用户。</p><h3 id="1-申请OAuth-Apps"><a href="#1-申请OAuth-Apps" class="headerlink" title="(1)申请OAuth Apps"></a>(1)申请OAuth Apps</h3><p>在github -&gt; settings -&gt; Developer Settings -&gt; OAuth Apps 中申请新的OAuth项目。</p><p><code>Authorization callback URL</code> 和 <code>Homepage URL</code> 属性都写<code>&lt;username&gt;</code>.github.io博客的地址。</p><p>并点击按钮，生成 clientSecret，下面会用到。</p><h3 id="2-填写gitalk的属性"><a href="#2-填写gitalk的属性" class="headerlink" title="(2)填写gitalk的属性"></a>(2)填写gitalk的属性</h3><p>修改项目中的<code>_config.yml</code>文件，我的在<code>theme/hexo-theme-Kaze/_config.yml</code>中。修改对应gitalk配置的部分。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">gitalk:</span><br>  <span class="hljs-attr">clientID:</span> <span class="hljs-string">&lt;clientID&gt;</span><br>  <span class="hljs-attr">clientSecret:</span> <span class="hljs-string">&lt;clientSecret&gt;</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">fuheihei.github.io</span><br>  <span class="hljs-attr">owner:</span> <span class="hljs-string">fuheihei</span><br>  <span class="hljs-attr">admin:</span> <span class="hljs-string">fuheihei</span><br>  <span class="hljs-attr">id:</span> <span class="hljs-string">location.href</span> <span class="hljs-comment"># dont modify</span><br>  <span class="hljs-attr">distractionFreeMode:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">language:</span> <span class="hljs-string">navigator.language</span> <span class="hljs-string">||</span> <span class="hljs-string">navigator.userLanguage</span><br>  <span class="hljs-attr">labels:</span> [<span class="hljs-string">&#x27;Gitalk&#x27;</span>]<br>  <span class="hljs-attr">perPage:</span> <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><h2 id="6-发布博客"><a href="#6-发布博客" class="headerlink" title="6.发布博客"></a>6.发布博客</h2><p>本地测试查看无误后，使用命令<code>hexo clean &amp;&amp; hexo deploy</code>可以上传change提交到<code>&#123;username&#125;</code>.github.io项目中。</p><p>提交结果如下图所示</p><img src='gitlog-commit.png' alt="提交记录demo图" width="80%" height="80%"><p style="text-align:center">提交记录demo图</p><p>可以看到<code>hexo deploy</code>指令会自动生成git的提交到repo上，通常是以时间作为commit的message。</p><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><p>经过上述的步骤，相信你也会有一个较好的博客了，接下来开始享受写作吧！</p>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
