[{"title":"并发编程 - 线程池 Thread Pool","url":"http://fuheihei.github.io/java-concurrency-programming/thread-pool/","content":"本文介绍了Java中的几种线程池，及Executors构造线程池的用法。\nJava 线程池 Thread Pool构建新线程的开销较大。如果程序中需要创建大量很短生命期的线程，应该使用线程池，而不是将每个任务映射到一个单独线程。\n线程池中包含很多准备运行的线程，每为线程池提供一个Runnable实例，就会有一个池中的线程调用run方法。当run方法退出时，这个线程不会死亡，而是留在池中准备为下一个请求 (Runnable实例) 提供服务。\n执行器 Executors执行器有许多静态工厂方法，用来构造线程池。静态工厂方法返回类型为 ExecutorService\n 表格 Executors工厂方法 \n\n\n\n\n方法\n描述\n\n\n\nnewCachedThreadPool\n必要时创建新线程；空闲线程会保留60 s\n\n\nnewFixedThreadPool\n池中包含固定数目的线程；空闲线程会一直保留\n\n\nnewWorkStealingPool\n一种适合“fork-join”任务的线程池，其中复杂的任务会分解为更简单的任务，空闲线程会“密取”较简单的任务\n\n\nnewSingleThreadExecutor\n只有一个线程的“池”，会顺序地执行所提交的任务\n\n\nnewScheduledThreadPool\n用于调度执行的固定线程池\n\n\nnewSingleThreadScheduledExecutor\n用于调度执行的单线程池\n\n\n缓存线程池 newCachedThreadPool构造一个线程池，会立即执行各个任务。如果有空闲线程可用，就使用现有空闲线程执行任务；如果没有可用的空闲线程，则创建一个新线程。\n固定线程池 newFixedThreadPool构造一个固定大小的线程池。如果提交的任务数多于空闲线程数，就把未得到服务的任务放到队列中。当其他任务完成以后再运行这些排队的任务。\n单线程池 newSingleThreadExecutor是一个退化了的大小为1的线程池：由一个线程顺序地执行所提交的任务（顺序执行）。\n参考上面的 FixedThreadPool\n使用线程池的小结如果线程生存时间很短，或者大量时间都在阻塞，业务是轻量负载的，可以使用缓存线程池。\n为了获得最优的运行速度，业务是高负载的，可以令并发线程数等于处理内核数(查看CPU内核数方法见下文)。在这种情况下，就应该使用固定线程池，即并发线程总数有一个上限。\n单线程池对于性能分析很有帮助。如临时使用一个单线程池替换其他线程池，就能测量不适用并发的情况下应用的运行速度会慢多少。\n实际使用的时候推荐自己创建ThreadPoolExecutor (避免OOM)\n\nExecutors 返回线程池对象的弊端如下：\n\nFixedThreadPool 和 SingleThreadExecutor： 允许请求的队列长度为 &gt; Integer.MAX_VALUE,可能堆积大量的请求，从而导致 OOM。\nCachedThreadPool 和 ScheduledThreadPool ： 允许创建的线程数量为 &gt; Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。\n\n\n综合来讲，因为队列上限和创建线程上限，导致OOM发生。\n除了避免 OOM 的原因之外，不推荐使用 Executors 提供的两种快捷的线程池的原因还有：\n\n实际使用中需要根据自己机器的性能、业务场景来手动配置线程池的参数比如核心线程数、使用的任务队列、饱和策略等等。\n我们应该显示地给我们的线程池命名，这样有助于我们定位问题。\n\n如何查看CPU内核数量Linux: cat /proc/cpuinfo| grep &quot;cpu cores&quot;| uni\nMac: 查看物理内核 sysctl hw.physicalcpu\n逻辑内核 sysctl hw.logicalcpu\n\nExecutorService分析上文中的几种线程池都属于ThreadPoolExecutor类，实现了ExecutorService的接口。\n图 ExecutorService 继承关系\n\n\n\n\n\nFuture&lt;T> submit(Callable&lt;T> task);\nFuture&lt;?> submit(Runnable task);\nFuture&lt;T> submit(Runnable task, T result);\nvoid shutdown();\nList&lt;Runnable> shutdownNow();\n\n\n\n调用submit时，会得到Future对象，可用来得到结果(get)或者取消任务(cancel)。\n第二个submit返回的Future对象可以来调用isDone, cancel, isCancelled。但是get方法在完成的时候只是简单返回null。\n第三个submit也生成一个Future，它的get方法在完成的时候返回指定的result对象。\nshutdown 用于关闭线程池，被关闭的线程池不再接受新任务，当所有任务完成时，线程池中的线程死亡。\nshutdownNow 会取消所有尚未开始的任务。\n\nfork-join框架有一些应用可能对处理器内核分别使用一个线程，以完成计算密集型任务，如图像或视频处理的应用。Java 7 中新引入了fork-join框架，专门用来支持这一类应用。\n假设有一个处理任务，它可以很自然地分解为子任务，如下所示\nif problemSize &lt; threshold\n\tsolve problem directly\nelse\n&#123;\n\tbreak problem into subproblems\n\trecursively solve each subproblem\n\tconbine the results\n&#125;\n\n\n\n为了完成这种递归计算，需要提供扩展RecursiveTask&lt;T&gt;的类或者提供扩展RecursiveAction&lt;T&gt;的类。再覆盖compute方法来生成并调用子任务。\n例如\npublic class Counter extends RecursiveTask&lt;Integer> &#123;\n\n    private static final int THRESHOLD = 10;\n    int to, from;\n    private DoublePredicate filter;\n    int[] values;\n\n    public Counter(int[] numbers, int from, int to, DoublePredicate filter) &#123;\n        this.values = numbers;\n        this.from = from;\n        this.to = to;\n        this.filter = filter;\n    &#125;\n\n    @Override\n    protected Integer compute() &#123;\n        if (to - from &lt; THRESHOLD) &#123;\n            int count = 0;\n            for (int i = from; i &lt; to; i++) &#123;\n                if (filter.test(values[i])) count++;\n            &#125;\n            return count;\n        &#125; else &#123;\n            int mid = (to + from) / 2;\n            Counter first = new Counter(values, from, mid, filter);\n            Counter second = new Counter(values, mid, to, filter);\n            invokeAll(first, second);\n            return first.join() + second.join();\n        &#125;\n    &#125;\n&#125;\n\n\n\n在后台，fork-join采用了一种有效的智能方法来平衡可用线程的工作负载，这种方法称为工作密取(work-stealing)。一个工作线程将子任务压入双端队列的队头(只有一个线程可以访问队头，故可以不加锁)，另一个工作线程空闲时，它会从双端队列的队尾“密取”一个任务。\n\n⚠️警告: fork-join池是针对非阻塞工作负载优化的。如果向一个fork-join池增加很多阻塞任务，会使其无法有效工作。\n\n","categories":["concurrent"],"tags":["concurrent"]},{"title":"如何写博客","url":"http://fuheihei.github.io/tools/how-to-write-blog/","content":"我建立博客的初心是记录技术，并将自己在编程中学到的知识，写成规范的文档形式，尽力做到对自己对他人都是有帮助的。\n1. 文档工具文档文件格式还是markdown为主\n2. markdown写作规范写作规范详细参考github上的 Markdown 编写规范-中文\n3. 字体字体颜色，正常字体是默认的黑色，参考配色的颜色设计网站\n1 - FlatUI 配色\n2 - Ant Design 配色\n红色 #fe6673  重要的内容\n蓝色 #3498db 新名词首次出现\n黄色 #f1c40f warning警告相关的颜色\n绿色 #27ae60 论证过程，或者过程性质的代码\n如下所示，在md中嵌入html标签\n&lt;span style=\"color:...\"> &lt;/span> &lt;!--用标签包裹需要上色的文字-->\n\n\n\n4. 代码代码部分格式以markdown样式为主，分为大的代码块（带行号）和普通代码行。\nhello world //代码块\n\nhello world 普通代码行\n5. 总结每天进步一点点，保持笔记的清晰有条理。\n","categories":["tools"],"tags":["blog"]},{"title":"个人博客搭建","url":"http://fuheihei.github.io/tools/how-to-build-my-blog/","content":"搭建个人博客 hexo+kaze+gitalk。\n我们经常会看到github有人有&lt;username&gt;.github.io形式的个人博客网页，他们是怎么做到的呢？\n仔细观察，不少人的博客底部还会出现 “powered by hexo” 或者 “由hexo强力驱动” 的字样\n通过下文，你也可以搭建一个自己的github pages博客\n1.Github Pages没错，浏览器中url为&lt;username&gt;.github.io形式的博客是github提供的一种博客功能，这个功能叫做github pages。当用户在github上新建了&lt;username&gt;.github.io的public的仓库(&lt;username&gt;和自己的github用户名一致)，就可以为自己生成对应的github pages。并且其他访客可以通过这个url访问你的博客。\n2. hexo项目构建2.1用 hexo初始化项目第一步，安装hexo\n通过hexo-cli的方式，构建博客项目会更容易。\n环境：需要git，node环境(&gt;&#x3D;12.0.0, 推荐nvm安装node)\nnpm install hexo-cli -g\n\n\n\n详细安装配置可以看hexo官网文档 (简便安装上面一行指令就够了)\n第二步，接着hexo在本地构建项目\nhexo init &lt;project_url> #初始化项目\ncd &lt;project_url> #进入项目路径\n\n\n\n常用的hexo指令\nhexo g #即 hexo generate，生成静态文件\nhexo s #即 hexo server，本地运行服务器\nhexo d #即 hexo deploy，部署服务器，常用指令 hexo clean &amp;&amp; hexo d\n\n\n\n2.2 新建github pages 仓库新建一个github项目，项目名为&#96;&#96;{username}.github.io，项目是public的而非private的。\n修改本地hexo项目根目录下的 _config.yml文件，添加 deploy 相关的属性。\n需要指定发布项目的repo，这里因为我们用的是github pages，github pages通常是 &#123;username&#125;.github.io&#96;形式的public仓库。\n# Deployment\n## Docs: https://hexo.io/docs/one-command-deployment\ndeploy:\n  type: git\n  repo: git@github.com:fuheihei/fuheihei.github.io.git # 指定为你的github pages的git地址\n  branch: main #对应的git分支\n\n3.博客主题的选取hexo构建的博客项目可以选取很多开源的hexo主题，类似于qq空间的皮肤，我们通过修改根目录下_config.yml中的属性theme: 就能指定对应的皮肤。\n例如\n想要选择的主题是anatole\n将主题项目 git clone 到项目中的themes文件夹下，修改项目根目录下的_config.yml中的属性\ntheme: anatole  #将theme指定为anatole\n# Extensions\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\n\n需要注意的是，如果指定为anatole，那么项目必须得有theme&#x2F;anatole文件夹。\n其他丰富的hexo主题请查阅: https://hexo.io/themes/\n4.写文章4.1 新建文章hexo new [layout] &lt;title文章名>\n例如 hexo new post how-to-build-my-blog\n[layout]可以是 post、page 和 draft，其位置和source&#x2F;_post，source&#x2F;page，source&#x2F;_draft是相关联的。\n4.2 发布文章hexo g #即 hexo generate，生成静态文件\nhexo s #即 hexo server，本地运行服务器\nhexo d #即 hexo deploy，部署服务器，也可以用指令 hexo clean &amp;&amp; hexo d\nhexo d可以将本地的hexo 项目转换成github pages需要的项目发布在你的github repo中，在浏览器输入 &lt;username&gt;.github.io 就能看到和本地一样的hexo博客了。\n5.评论系统完善的博客还应该提供访问用户讨论的机会。\n\n\ngitalk的demo图\n\n评论系统有很多，出于免费和效率考虑，此处使用gitalk\ngitalk是github提供的评论系统，免费；同时gitalk的用户评论文章的内容可以在repo生成对应的issues，可以起到邮件通知的效果，保证及时回复用户。\n(1)申请OAuth Apps在github -&gt; settings -&gt; Developer Settings -&gt; OAuth Apps 中申请新的OAuth项目。\nAuthorization callback URL 和 Homepage URL 属性都写&lt;username&gt;.github.io博客的地址。\n并点击按钮，生成 clientSecret，下面会用到。\n(2)填写gitalk的属性修改项目中的_config.yml文件，我的在theme/hexo-theme-Kaze/_config.yml中。修改对应gitalk配置的部分。\ngitalk:\n  clientID: &lt;clientID>\n  clientSecret: &lt;clientSecret>\n  repo: fuheihei.github.io\n  owner: fuheihei\n  admin: fuheihei\n  id: location.href # dont modify\n  distractionFreeMode: false\n  language: navigator.language || navigator.userLanguage\n  labels: ['Gitalk']\n  perPage: 10\n\n6.发布博客本地测试查看无误后，使用命令hexo clean &amp;&amp; hexo deploy可以上传change提交到&#123;username&#125;.github.io项目中。\n提交结果如下图所示\n\n\n提交记录demo图\n\n可以看到hexo deploy指令会自动生成git的提交到repo上，通常是以时间作为commit的message。\n7. 总结经过上述的步骤，相信你也会有一个较好的博客了，接下来开始享受写作吧！\n","categories":["tools"],"tags":["blog"]}]